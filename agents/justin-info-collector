#!/usr/bin/env python3
#
# justin-info-collector - justIN info collector agent
#
# Copyright 2013-25, Andrew McNab for the University of Manchester
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

import os
import re
import sys
import stat
import pwd
import time
import ssl
import json
import socket
import urllib
import urllib.request
import pathlib
import tempfile
import warnings
import traceback
import subprocess
import rucio.client
import xml.dom.minidom

# WE NEED TO REMOVE OLD MySQLdb REFERENCES STILL!
import pymysql
pymysql.install_as_MySQLdb()
MySQLdb=pymysql

# Installed by pip install of Rucio
import rucio.client

# Needs python3-pyyaml RPM
import yaml

import justin

testRucioInterval      = 300
updateSitesInterval    = 3600
updateStoragesInterval = 3600
updateJwksInterval     = 86400

sleepSeconds = 60

def logLine(text):
  sys.stdout.write(time.strftime('%b %d %H:%M:%S [') + str(os.getpid()) + ']: ' + text + '\n')
  sys.stdout.flush()

def getJsonURL(url):
  httpRequest = urllib.request.Request(url)
  sslContext  = ssl.SSLContext()
  sslContext.verify_mode = ssl.CERT_REQUIRED
  sslContext.check_hostname = True
  sslContext.load_verify_locations(capath = '/etc/grid-security/certificates')

  try:
    response = urllib.request.urlopen(httpRequest, context = sslContext)
  except Exception as e:
    logLine('Get JSON URL workflow fails: ' + str(e))
    return None
  else:
    if response.status != 200:
      logLine('Get JSON URL response not 200, code=%d' 
              % response.status)
      return None

  try:
    responseData = response.read().decode('utf-8')
    responseDict = json.loads(responseData)
  except Exception as e:
    logLine('Failed loading json: ' + str(e))
    return None

  return responseDict

def executeMetaCatCommand(args):

  for i in range(1, 4):
    ret = os.system(
     'export X509_USER_PROXY=%s ; '
     'export METACAT_AUTH_SERVER_URL=%s ; '
     'export METACAT_SERVER_URL=%s ; '
     '/usr/local/bin/metacat auth login -m x509 dunepro ; '
     '/usr/local/bin/metacat %s' % 
     (justin.jobsProductionProxyFile, 
      justin.metacatAuthServerURL, justin.metacatServerOutputsURL,
      args))
     
    if ret == 0:
      break

    time.sleep(1) 

  return ret

def testRucio():
  # Use rucio ping to test Rucio
  logLine('---- Start testRucio ----')

  pingRucioMilliseconds = justin.pingRucioMilliseconds()
  
  try:
    query = ('REPLACE keys_names_values SET '
             'key_name="ping_rucio_milliseconds",'
             'key_value="%d"'
             % pingRucioMilliseconds)

    justin.select(query)
  except Exception as e:
    # Log the error 
    logLine('Failed putting ping Rucio milliseconds into database: %s' 
              % str(e))

  justin.conn.commit()
  logLine('---- End testRucio ----')
 
def updateJwks():
  logLine('Start update of JWT keys')

  # Upate the database with current JWT keys for DUNE from CILogon 
  openidConfiguration = getJsonURL(
              'https://cilogon.org/dune/.well-known/openid-configuration')
              
  if openidConfiguration and 'jwks_uri' in openidConfiguration:
    cilogonJwks = getJsonURL(openidConfiguration['jwks_uri'])
    if cilogonJwks and 'keys' in cilogonJwks:
      for jwtKey in cilogonJwks['keys']:
        if (not justin.stringIsSite(jwtKey['n']) or 
            not justin.stringIsSite(jwtKey['e']) or 
            not justin.stringIsSite(jwtKey['alg']) or 
            not justin.stringIsSite(jwtKey['kid']) or 
            not justin.stringIsSite(jwtKey['use']) or 
            not justin.stringIsSite(jwtKey['kty'])):
          logLine('Problem with key format')
          continue
      
        try:
          justin.insertUpdate('REPLACE INTO jwt_keys SET '
                              'jwks_n="%s",'
                              'jwks_e="%s",'
                              'jwks_alg="%s",'
                              'jwks_kid="%s",'
                              'jwks_use="%s",'
                              'jwks_kty="%s"'
                              % (jwtKey['n'], jwtKey['e'], jwtKey['alg'],
                                 jwtKey['kid'], jwtKey['use'], jwtKey['kty']))
        except Exception as e:                         
          logLine('Failed updating JWKS: ' + str(e))
        else:
          logLine('Updating JWT key kid=%s' % jwtKey['kid'])
 
      justin.conn.commit()
      return
      
  logLine('Failed updating CILogon JWT keys')

def cleanupNodeXML(node):
  if node.nodeType == xml.dom.Node.TEXT_NODE \
     and node.nodeValue.strip() == "":
    node.nodeValue = ""
  
  for childNode in node.childNodes:
    cleanupNodeXML(childNode)

def processOneFileXML(sitesDict, fileName):

  try:
    xmlStr = open(fileName).read()
    xmlDocument = xml.dom.minidom.parseString(xmlStr)
  except Exception as e:
    logLine('Parsing XML file %s fails with: %s' % (fileName, str(e)))
    return

  cleanupNodeXML(xmlDocument)
  xmlDocument.normalize()

  xmlEntries = xmlDocument.firstChild.firstChild

  for xmlEntry in xmlEntries.childNodes:

    # Find an entry and process it
    if xmlEntry.nodeType == xml.dom.Node.ELEMENT_NODE and \
       xmlEntry.tagName == 'entry':

      try:
        entryName = xmlEntry.getAttribute('name')
      except:
        continue

      try:
        gatekeeper = xmlEntry.getAttribute('gatekeeper').split(' ')[0]
      except:
        gatekeeper = entryName

      try:
        entryEnabled = xmlEntry.getAttribute('enabled')
      except:
        entryEnabled = 'True'

      try:
        gridType = xmlEntry.getAttribute('gridtype')
      except:
        gridType = ''

      if entryEnabled == 'False' or gridType == 'cream':
        continue

      siteName        = None
      jobsubSiteName  = None
      wlcgSiteName    = ''
      voList          = []
      processors      = 1
      rssBytes        = 2000 * 1024 * 1024
      wallSeconds     = 86400            

      # Assemble the GLIDEIN values for this entry
      for xmlEntryChild in xmlEntry.childNodes:
        if xmlEntryChild.nodeType == xml.dom.Node.ELEMENT_NODE and \
           xmlEntryChild.tagName == 'attrs':

          for xmlAttr in xmlEntryChild.childNodes:
            
            if xmlAttr.nodeType == xml.dom.Node.ELEMENT_NODE and \
               xmlAttr.tagName == 'attr':
               
              name  = xmlAttr.getAttribute('name')
              value = xmlAttr.getAttribute('value')
               
              if name == 'GLIDEIN_DUNESite':
                siteName = xmlAttr.getAttribute('value')

              elif name == 'GLIDEIN_Site':
                jobsubSiteName = xmlAttr.getAttribute('value')

              elif name == 'GLIDEIN_ResourceName':
                # This is because UKI-SCOTGRID-DURHAM has a space!
                wlcgSiteName = xmlAttr.getAttribute('value').strip()

              elif name == 'GLIDEIN_CPUS':
                try:
                  processors = int(xmlAttr.getAttribute('value'))
                except:
                  pass
                
              elif name == 'GLIDEIN_MaxMemMBs':
                try:
                  rssBytes = int(xmlAttr.getAttribute('value')) * 1048576
                except:
                  pass
                
              elif name == 'GLIDEIN_Max_Walltime':
                try:
                  wallSeconds = int(xmlAttr.getAttribute('value'))
                except:
                  pass
                
              elif name == 'GLIDEIN_Supported_VOs':
                voList = xmlAttr.getAttribute('value').split(',')

      # If we found the necessary GLIDEIN values, then carry on
      if (siteName and jobsubSiteName and processors and rssBytes and 
          wallSeconds and (('DUNE' in voList) or ('DUNEGPU' in voList))):

        if siteName not in sitesDict:
          logLine("Add %s" % siteName)

          sitesDict[siteName] = { 'jobsub_site_name'      : jobsubSiteName,
                                  'wlcg_site_name'        : wlcgSiteName,
                                  'only_production'       : False,
                                  'only_on_request'       : False,
                                  'entries'               : []
                                }

        logLine('Add %s:%s' % (siteName, entryName))
        sitesDict[siteName]['entries'].append(
               { 'entry_name'      : entryName,
                 'gatekeeper'      : gatekeeper,
                 'max_rss_bytes'   : rssBytes,
                 'max_wall_seconds': wallSeconds,
                 'max_processors'  : processors,
                 'entry_has_gpus'  : True if 'DUNEGPU' in voList else False,
                 'file_name'       : fileName.split('/')[-1],
                 'raw_config'      : xmlEntry.toprettyxml(indent="    ",
                                                  encoding="UTF-8").decode() 
               })

def processOneFileYAML(sitesDict, fileName):

  try:
    yamlDict = yaml.safe_load(open(fileName,'r'))
  except Exception as e:
    logLine('Parsing YAML file %s fails with: %s' % (fileName, str(e)))
    return
    
  logLine('Parsing YAML file %s' % fileName)

  for osgSiteName in yamlDict:
    for osgGatekeeper in yamlDict[osgSiteName]:
      if osgGatekeeper == 'common_entry_fields':
        logLine('Skipping common_entry_fields of %s' % osgSiteName)
        continue
    
      if 'BEST_FIT' not in yamlDict[osgSiteName][osgGatekeeper]:
        logLine('%s:%s has no BEST_FIT - ignoring' 
                % (osgSiteName,osgGatekeeper))
        continue
    
      for entryName in yamlDict[osgSiteName][osgGatekeeper]['BEST_FIT']:
        if (not yamlDict[osgSiteName][osgGatekeeper]['BEST_FIT'][entryName] 
            or 'attrs' not in 
            yamlDict[osgSiteName][osgGatekeeper]['BEST_FIT'][entryName]):
          logLine('%s has no attrs! - ignoring' % entryName)
          continue

        # Check if this entry even supports DUNE
        try:
          voList = yamlDict[osgSiteName][osgGatekeeper]['BEST_FIT']\
                           [entryName]['attrs']['GLIDEIN_Supported_VOs']\
                           ['value'].split(',')
        except:
          try:
            voList = yamlDict[osgSiteName]['common_entry_fields']\
                             ['attrs']['GLIDEIN_Supported_VOs']\
                             ['value'].split(',')
          except:
            voList = []
          
        # GLIDEIN_Site = justIN jobsubSiteName
        try:
          jobsubSiteName = yamlDict[osgSiteName][osgGatekeeper]\
                     ['BEST_FIT'][entryName]['attrs']['GLIDEIN_Site']['value']
        except:
          try:
            jobsubSiteName = yamlDict[osgSiteName]['common_entry_fields']\
                               ['attrs']['GLIDEIN_Site']['value']
          except:
            jobsubSiteName = None

        if not jobsubSiteName:
          logLine('%s has no GLIDEIN_Site - ignoring' % entryName)
          continue

        # GLIDEIN_DUNESite = justIN siteName
        try:
          siteName = yamlDict[osgSiteName][osgGatekeeper]['BEST_FIT']\
                       [entryName]['attrs']['GLIDEIN_DUNESite']['value']
        except:
          try:
            siteName = yamlDict[osgSiteName]['common_entry_fields']\
                         ['attrs']['GLIDEIN_DUNESite']['value']
          except:
            siteName = None

        if not siteName:
          logLine('%s has no GLIDEIN_DUNESite - ignoring' % entryName)
          continue

        # GLIDEIN_ResourceName = justIN wlcgSiteName
        try:
          wlcgSiteName = yamlDict[osgSiteName][osgGatekeeper]['BEST_FIT']\
                          [entryName]['attrs']['GLIDEIN_ResourceName']['value']
        except:
          try:
            wlcgSiteName = yamlDict[osgSiteName]['common_entry_fields']\
                             ['attrs']['GLIDEIN_ResourceName']['value'] 
          except:
            wlcgSiteName = ''

        # GLIDEIN_CPUS = justIN processors
        try:
          processors = int(yamlDict[osgSiteName][osgGatekeeper]['BEST_FIT']\
                            [entryName]['attrs']['GLIDEIN_CPUS']['value'])
        except:
          try:
            processors = int(yamlDict[osgSiteName]['common_entry_fields']\
                               ['attrs']['GLIDEIN_CPUS']['value'])
          except:
            processors = 1

        # GLIDEIN_MaxMemMBs = justIN rssBytes        
        try:
          rssBytes = 1024 * 1024 * int(yamlDict[osgSiteName][osgGatekeeper]\
                ['BEST_FIT'][entryName]['attrs']['GLIDEIN_MaxMemMBs']['value'])
        except:
          try:
            rssBytes = 1024 * 1024 * int(yamlDict[osgSiteName]\
              ['common_entry_fields']['attrs']['GLIDEIN_MaxMemMBs']['value'])
          except:
            # default from OSG_autoconf/etc/default.yml
            rssBytes = 2500 * 1024 * 1024

        # GLIDEIN_Max_Walltime = justIN wallSeconds
        try:
          wallSeconds = int(yamlDict[osgSiteName][osgGatekeeper]['BEST_FIT']\
                [entryName]['attrs']['GLIDEIN_Max_Walltime']['value'])
        except:
          try:
            wallSeconds = int(yamlDict[osgSiteName]['common_entry_fields']\
                                 ['attrs']['GLIDEIN_Max_Walltime']['value'])
          except:
            wallSeconds = 86400

        if ('DUNE' not in voList) and ('DUNEGPU' not in voList):
          logLine('%s does not support DUNE - ignoring' % entryName)
          continue

        # Add to sitesDict if not already there
        if siteName not in sitesDict:
          logLine("Add %s" % siteName)

          sitesDict[siteName] = { 'jobsub_site_name'      : jobsubSiteName,
                                  'wlcg_site_name'        : wlcgSiteName,
                                  'only_production'       : False,
                                  'only_on_request'       : False,
                                  'entries'               : []
                                }

        rawConfig = { entryName : 
             yamlDict[osgSiteName][osgGatekeeper]['BEST_FIT'][entryName] }
  
        if 'common_entry_fields' in yamlDict[osgSiteName]:
          rawConfig['common_entry_fields'] = \
                         yamlDict[osgSiteName]['common_entry_fields']

        sitesDict[siteName]['entries'].append(
              { 'entry_name'      : entryName,
                'gatekeeper'      : osgGatekeeper,
                'max_rss_bytes'   : rssBytes,
                'max_wall_seconds': wallSeconds,
                'max_processors'  : processors,
                'entry_has_gpus'  : True if 'DUNEGPU' in voList else False,
                'file_name'       : 'OSG_autoconf/' + fileName.split('/')[-1],
                'raw_config'      : json.dumps(rawConfig, 
                                             sort_keys = True, indent = 4)
              })

def addExtraEntries(sitesDict):

  for entryName,entryFields in justin.extraEntries:
    try:
      entryDict = {}
      for field in entryFields.split():
        if '=' in field:
          fieldName,fieldValue = field.split('=')
          entryDict[fieldName] = fieldValue

      logLine(str(entryDict))

      # These fields are required and the entry will be skiped if missing
      for i in ['site_name', 'jobsub_site_name',
                'max_rss_bytes', 'max_wall_seconds', 'max_processors']:
        if i not in entryDict:
          logLine('No %s in %s - skipping' % (i, entryName))
          raise

      # Optional site fields
      if 'wlcg_site_name' in entryDict and entryDict['wlcg_site_name']:
        wlcgSiteName = entryDict['wlcg_site_name']
      else:
        wlcgSiteName = entryDict['site_name']
        
      try:
        onlyProduction = (True 
                          if (entryDict['only_production'].lower() == 'true') 
                          else False)
      except:
        onlyProduction = False

      try:
        onlyOnRequest = (True 
                         if (entryDict['only_on_request'].lower() == 'true') 
                         else False)
      except:
        onlyOnRequest = False

      if entryDict['site_name'] not in sitesDict:
        logLine("Add %s" % entryDict['site_name'])
        # We take the site fields from the first entry seen for that site
        sitesDict[entryDict['site_name']] = {
             'jobsub_site_name' : entryDict['jobsub_site_name'],
             'wlcg_site_name'   : wlcgSiteName,
             'only_production'  : onlyProduction,
             'only_on_request'  : onlyOnRequest,
             'entries'          : []        }

      # Optional entry fields
      try:
        entryHasGPUs = (True 
                        if (entryDict['entry_has_gpus'].lower() == 'true') 
                        else False)
      except Exception as e:
        entryHasGPUs = False

      if 'gatekeeper' in entryDict and entryDict['gatekeeper']:
        gatekeeper = entryDict['gatekeeper']
      else:
        gatekeeper = entryName

      sitesDict[entryDict['site_name']]['entries'].append(
              { 'entry_name'      : entryName,
                'gatekeeper'      : gatekeeper,
                'max_rss_bytes'   : int(entryDict['max_rss_bytes']),
                'max_wall_seconds': int(entryDict['max_wall_seconds']),
                'max_processors'  : int(entryDict['max_processors']),
                'entry_has_gpus'  : entryHasGPUs,
                'file_name'       : '',
                'raw_config'      : str(entryDict)
              })
    except Exception as e:
      logLine('Skip entry %s due to %s' % (entryName, str(e)))
      continue

def buildSites(sitesDict):

  tmpDir = tempfile.TemporaryDirectory()
  os.system('cd /tmp ; printenv ; git '
            'clone -v -v -v https://github.com/opensciencegrid/osg-gfactory.git '
             + tmpDir.name)

  for fileName in os.listdir(tmpDir.name):
    if fileName[-4:] == '.xml':
      logLine('Process XML file: %s' % fileName)
      processOneFileXML(sitesDict, tmpDir.name + '/' + fileName)

  for fileName in os.listdir(tmpDir.name + '/OSG_autoconf'):
    if fileName[-4:] == '.yml':
      logLine('Process YAML file: %s' % fileName)
      processOneFileYAML(sitesDict, tmpDir.name + '/OSG_autoconf/' + fileName)

  # Add extras from justIN config
  addExtraEntries(sitesDict)

def updateSites():
  # Get info about sites the pilot factories know about
  logLine('---- Start updateSites ----')

  sitesDict = {}
  buildSites(sitesDict)

#  logLine(str(sitesDict))

  try:
    justinSiteRows = justin.select('SELECT site_name,sites.site_id,'
                                   'entry_name,entry_id FROM sites '
                                   'LEFT JOIN entries '
                                   'ON entries.site_id=sites.site_id '
                                   'ORDER BY site_name,entry_name')
  except Exception as e:
    logLine('Failed to get list of existing sites from justIN: ' + str(e))
    return

  justinSiteIDs  = {}
  justinEntryIDs = {}
  lastSiteName = ''
  for justinSiteRow in justinSiteRows:
    if justinSiteRow['site_name'] != lastSiteName:
      justinSiteIDs[justinSiteRow['site_name']] = justinSiteRow['site_id']
      lastSiteName = justinSiteRow['site_name']
    justinEntryIDs[justinSiteRow['entry_name']] = \
      justinSiteRow['entry_id']

  for siteName in sitesDict:

    if siteName == 'CERN':
      country = 'CERN'
    else:
      country = siteName[:2]

    if country in justin.rseCountriesRegions:
      region = justin.rseCountriesRegions[country]
    else:
      region = ''

    # Ensure the site exists
    if siteName not in justinSiteIDs:
      query = ('INSERT INTO sites SET '
               'site_name="%s",'
               'jobsub_site_name="%s",'
               'wlcg_site_name="%s",'
               'only_production=%d,'
               'only_on_request=%d,'
               'country="%s",'
               'region="%s",'
               'last_osg_seen_time=NOW() '
               % (siteName, 
                  sitesDict[siteName]['jobsub_site_name'], 
                  sitesDict[siteName]['wlcg_site_name'],
                  int(sitesDict[siteName]['only_production']),
                  int(sitesDict[siteName]['only_on_request']),
                  country,
                  region)
              )
      try:
        newID = justin.insertUpdate(query)
      except Exception as e:
        logLine('Failed inserting %s: %s' % (siteName, str(e)))
        continue
      else:
        justinSiteIDs[siteName] = newID

    else:
      query = ('UPDATE sites SET '
               'jobsub_site_name="%s",'
               'wlcg_site_name="%s",'
               'only_production=%d,'
               'only_on_request=%d,'
               'country="%s",'
               'region="%s",'
               'last_osg_seen_time=NOW() '
               'WHERE site_name="%s"'
               % (sitesDict[siteName]['jobsub_site_name'],
                  sitesDict[siteName]['wlcg_site_name'],
                  int(sitesDict[siteName]['only_production']),
                  int(sitesDict[siteName]['only_on_request']),
                  country,
                  region,
                  siteName
                 )
              )
      try:
        justin.insertUpdate(query)
      except Exception as e:
        logLine('Failed updating %s: %s' % (siteName, str(e)))
        continue

    for entryDict in sitesDict[siteName]['entries']:
       logLine('Insert/update ' + entryDict['entry_name'])
       if entryDict['entry_name'] not in justinEntryIDs:
          query = ('INSERT INTO entries SET '
                   'entry_name="%s",'
                   'gatekeeper="%s",'
                   'site_id=%d,'
                   'max_processors=%d,'
                   'max_rss_bytes=%d,'
                   'max_wall_seconds=%d,'
                   'entry_has_gpus=%d,'
                   'file_name="%s",'
                   'raw_config="%s",'
                   'last_osg_seen_time=NOW() '
                   % (entryDict['entry_name'], 
                      entryDict['gatekeeper'],
                      justinSiteIDs[siteName],
                      entryDict['max_processors'],
                      entryDict['max_rss_bytes'],
                      entryDict['max_wall_seconds'],
                      int(entryDict['entry_has_gpus']),
                      entryDict['file_name'],
             entryDict['raw_config'].replace('\\','\\\\').replace('"','\\"'))
                  )

#          logLine(query)
          try:
            newID = justin.insertUpdate(query)
          except Exception as e:
            logLine('Failed inserting %s: %s' 
                  % (entryDict['entry_name'], str(e)))
            continue
          else:
            justinEntryIDs[entryDict['entry_name']] = newID

       else:
          query = ('UPDATE entries SET '
                   'gatekeeper="%s",'
                   'site_id=%d,'
                   'max_processors=%d,'
                   'max_rss_bytes=%d,'
                   'max_wall_seconds=%d,'
                   'entry_has_gpus=%d,'
                   'file_name="%s",'
                   'raw_config="%s",'
                   'last_osg_seen_time=NOW() '
                   'WHERE entry_name="%s"'
                   % (entryDict['gatekeeper'],
                      justinSiteIDs[siteName],
                      entryDict['max_processors'],
                      entryDict['max_rss_bytes'],
                      entryDict['max_wall_seconds'],
                      int(entryDict['entry_has_gpus']),
                      entryDict['file_name'],
             entryDict['raw_config'].replace('\\','\\\\').replace('"','\\"'),
                      entryDict['entry_name']
                     )
                  )
#          logLine(query)
          try:
            justin.insertUpdate(query)
          except Exception as e:
            logLine('Failed inserting/updating %s: %s' 
                    % (entryDict['entry_name'], str(e)))
            continue

       logLine('Entry: %s' % entryDict['entry_name'])

    logLine('Site: %s' % siteName)

  justin.conn.commit()

def updateSitesStorages(): 
  # Update the matrix of sites to storage mappings
  # Ensure there is an entry for each combination
  logLine('---- Start updateSitesStorages ----')

  justin.cur.execute('SELECT site_id,site_name,country,region FROM sites')
  siteRows = justin.cur.fetchall()
  
  for siteRow in siteRows:
    justin.cur.execute('SELECT storages.rse_id,storages.rse_name,'
                       'storages.country,storages.region,'
                       'sites.site_name AS rse_site_name,'
                       'sites_storages.rse_id AS sites_storages_rse_id '
                       'FROM storages '
                       'LEFT JOIN sites '
                       'ON sites.site_id=storages.site_id '
                       'LEFT JOIN sites_storages '
                       'ON sites_storages.rse_id=storages.rse_id '
                       'AND sites_storages.site_id=%d' 
                       % siteRow['site_id'])
    storageRows = justin.cur.fetchall()
  
    for storageRow in storageRows:

      logLine(str(storageRow))
  
      sitePrefix = siteRow['site_name'].split('-')[0]
      if storageRow['rse_site_name']:
        rseSitePrefix = storageRow['rse_site_name'].split('-')[0]
      else:
        rseSitePrefix = ''
    
      if siteRow['site_name'] == storageRow['rse_site_name'] \
         or storageRow['rse_id'] == justin.MonteCarloRseID:
        # RSEs at sites and MC counter files have zero distance
        distance = 0
      elif siteRow['site_name'].startswith('US_FNAL') \
        and storageRow['rse_site_name'] \
        and storageRow['rse_site_name'].startswith('US_FNAL'):
        # Everything Fermilab at zero distance to get internal Rucio config
        distance = 0
      elif siteRow['site_name'].startswith('US_NERSC') \
        and 'NERSC' in storageRow['rse_name']:
        # Everything at NERSC is zero distance
        distance = 0
      elif 'NERSC' in storageRow['rse_name']:
        # Otherwise if NERSC storage then distance = unmatchable
        distance = 101
      elif sitePrefix and rseSitePrefix \
           and sitePrefix == rseSitePrefix:
        # Same prefix on RSE and site name 
        distance = 10
      elif siteRow['site_name'] == 'NL_NIKHEF' \
           and storageRow['rse_site_name'] == 'NL_SURFSARA':
        # NIKHEF and SURFSARA are together
        distance = 10
      elif siteRow['site_name'] == 'NL_SURFSARA' \
           and storageRow['rse_site_name'] == 'NL_NIKHEF':
        # NIKHEF and SURFSARA are together
        distance = 10
      elif siteRow['country'] and \
           siteRow['country'] == storageRow['country']:
        # Same country as just 20
        distance = 20
      elif siteRow['region'] and \
           siteRow['region'] == storageRow['region']:
        # Same region, so distance 30
        distance = 30
      elif storageRow['rse_site_name'] in ['CERN', 'US_FNAL-FermiGrid']:
        # Catchall if RSE at CERN/FNAL then 90
        distance = 90
      else:
        # Catchall if nothing chosen above.
        distance = 100

      if storageRow['sites_storages_rse_id'] is None:
        # Not there yet, so insert
        try:
          justin.insertUpdate('INSERT INTO sites_storages SET '
                              'distance=%d,site_id=%d,rse_id=%d'
                   % (distance, siteRow['site_id'], storageRow['rse_id']))
        except Exception as e:
          logLine('INSERT fails with ' + str(e))
      else:
        # Already have a value, so update
        try:
          justin.insertUpdate('UPDATE sites_storages SET '
                             'distance=%d WHERE site_id=%d AND rse_id=%d'
                   % (distance, siteRow['site_id'], storageRow['rse_id']))
        except Exception as e:
          logLine('UPDATE fails with ' + str(e))
              
  justin.conn.commit()

def updateStorages():
  # Get info about storages Rucio knows about
  logLine('---- Start updateStorages ----')
  
  # Ensure the dummy MONTECARLO RSE exists, with rse_id 1
  justin.cur.execute('INSERT IGNORE INTO storages SET rse_id=%d,'
    'rse_name="MONTECARLO",occupancy=1,rucio_write=FALSE,'
    'rucio_read=TRUE,justin_write=FALSE,justin_read=TRUE'
    % justin.MonteCarloRseID)

  justinStorageNames = []
  try:
    justinStorageRows = justin.select('SELECT rse_name FROM storages')
  except Exception as e:
    logLine('Failed to get names of existing justIN storages')
    return
    
  for justinStorageRow in justinStorageRows:
    justinStorageNames.append(justinStorageRow['rse_name'])

  try:
    rseClient = rucio.client.rseclient.RSEClient()
  except Exception as e:
    logLine("Connect to Rucio fails with: " + str(e))
    return
  
  try:
    accountClient = rucio.client.accountclient.AccountClient()
  except Exception as e:
    logLine("Connect to Rucio fails with: " + str(e))
    return
  
  try:
    rseList = rseClient.list_rses()  
  except Exception as e:
    logLine("Reading RSE list from Rucio fails with: " + str(e))
    return

  for rse in rseList:
  
    if not justin.stringIsSite(rse['rse']):
      logLine('Skip RSE with bad name %s' % rse['rse'])
      continue
  
    try:
      attributes = rseClient.list_rse_attributes(rse['rse'])
    except:
      logLine('Failed to get attributes for %s' % rse['rse'])
      continue

    logLine('Processing %s: %s' % (rse['rse'], rse))

    if (rse['rse_type'] != 'DISK' and rse['rse'] != 'FNAL_DCACHE') \
       or ('decommissioned' in attributes and 
           attributes['decommissioned'] == True):
      rseDecommissioned = True
    else:
      rseDecommissioned = False

    availabilityRead = rse['availability_read']

    if rse['deterministic']:
      availabilityWrite = rse['availability_write']
    else:
      # Force non-deterministic RSEs to read only
      availabilityWrite = False

    bestLanWriteScheme   = 'root'
    bestLanWritePriority = None

    bestWanWriteScheme   = 'root'
    bestWanWritePriority = None

    try:
      protocols = rseClient.get_protocols(rse['rse'])
    except Exception as e:
      logLine('Failed getting protocols for RSE %s: %s' 
              % (rse['rse'], str(e)))
      protocols = []

    for protocolDict in protocols:
      try:
        scheme = protocolDict['scheme']
      except:
        continue
      
      if scheme not in ['root', 'roots', 'https', 'davs']:
        continue
      
      try: 
        priority = protocolDict['domains']['lan']['write']
      except:
        pass
      else:
        if (priority > 0) and \
           (bestLanWritePriority is None or 
            priority < bestLanWritePriority or
            (priority == bestLanWritePriority and scheme < bestLanWriteScheme)):
          bestLanWriteScheme   = scheme
          bestLanWritePriority = priority
        
      try: 
        priority = protocolDict['domains']['wan']['write']
      except:
        pass
      else:
        if (priority > 0) and \
           (bestWanWritePriority is None or 
            priority < bestWanWritePriority or           
            (priority == bestWanWritePriority and scheme < bestWanWriteScheme)):
          bestWanWriteScheme   = scheme
          bestWanWritePriority = priority

    rseCountry = ''
    rseRegion  = ''
    if 'country' in attributes:
      rseCountry = attributes['country']
      if rseCountry in justin.rseCountriesRegions:
        rseRegion = justin.rseCountriesRegions[rseCountry]
  
    try:
      row = justin.select('SELECT site_id FROM sites WHERE site_name="%s"' 
                          % attributes['site'], justOne=True)
      rseSiteID = int(row['site_id'])
    except:
      rseSiteID = 0
      
    try:
      usageList = rseClient.get_rse_usage(rse['rse'],
                                          filters = {"source": "rucio"})
    except Exception as e:
      logLine("Reading %s usage fails with: %s" % 
              (rse['rse'], str(e)))
 
      occupancy = 0.0

    else:
      try:
        accLimits = accountClient.get_account_limits('dunepro', 
                                                     rse['rse'], 
                                                     'local')
      except Exception as e:
        logLine("Reading %s account limits fails with: %s" % 
                (rse['rse'], str(e)))
             
      try:
        usage     = next(usageList)        
        occupancy = float(usage['used']) / float(accLimits[rse['rse']])
      except:
        occupancy = 0.0

    try:
      if rse['rse'] not in justinStorageNames:
        query = ('INSERT INTO storages SET rse_name="%s",justin_write=FALSE'
                 % rse['rse']) 
        justin.select(query)

      query = ('UPDATE storages SET '
               'occupancy=%f,'
               'rucio_write=%s,rucio_read=%s,'
               'decommissioned=%s,'
               'region="%s",'
               'country="%s",'
               'site_id=%d,'
               'lan_write_scheme="%s",wan_write_scheme="%s",'
               'needs_pin=%s '
               'WHERE rse_name="%s"'
               % (occupancy,
                  availabilityWrite,
                  availabilityRead,
                  rseDecommissioned,
                  rseRegion,
                  rseCountry,
                  rseSiteID,
                  bestLanWriteScheme, bestWanWriteScheme,
                  'TRUE' if 'FNAL_DCACHE' in rse['rse'] else 'FALSE',
                  rse['rse']
                 )
              )

      justin.select(query)
    except Exception as e:
      # Log the error and hope it was transitory
      logLine('Failed inserting RSE %s into database: %s' % 
              (rse['rse'], str(e)))

  justin.conn.commit()

def updateStoragesQuotas():
  # Get info about storage quotas Rucio knows about
  logLine('---- Start updateStoragesQuotas ----')
  
  try:
    accountClient = rucio.client.accountclient.AccountClient()
  except Exception as e:
    logLine("Connect to Rucio fails with: " + str(e))
    return

  try:
    storageRows = justin.select('SELECT rse_id,rse_name FROM storages')
  except:
    logLine('Failed to get list of storages')
    return

  storages = {}
  for storage in storageRows:
    storages[storage['rse_name']] = storage['rse_id']

  try:
    namedQuotaRows = justin.select('SELECT quota_id,quota_name '
                                   'FROM named_quotas WHERE for_justin')
  except:
    logLine('Failed to get list of named_quotas')
    return

  for namedQuotaRow in namedQuotaRows:  
  
    rucioAccountName = namedQuotaRow['quota_name']
    # THIS CAN BE REMOVED ONCE ALL USERS HAVE PERSONAL NAMED QUOTAS
    if rucioAccountName == 'usertests':
      rucioAccountName = 'dunepro'
    
    try:
      accountUsages = \
          accountClient.get_local_account_usage(rucioAccountName)
    except Exception as e:
      logLine('Failed to get accountUsages for %s: %s' 
              % (rucioAccountName, str(e)))
      continue      
  
    for usage in accountUsages:
      logLine(str(usage))
    
      if usage['rse'] not in storages:
        logLine('Quota exists for RSE %s in Rucio but not in justIN DB '
                '- skipping' % usage['rse'])
        continue

      if usage['bytes'] == float('inf'):
        usage['bytes'] = 18446744073709551615

      if usage['bytes_limit'] == float('inf'):
        usage['bytes_limit'] = 18446744073709551615

      rseID = storages[usage['rse']]

      try:
        justin.insertUpdate('REPLACE INTO storages_quotas '
                          'SET quota_id=%d,rse_id=%d,bytes=%d,bytes_limit=%d,'
                          'last_seen_time=NOW()'
                          % (namedQuotaRow['quota_id'],
                             rseID,
                             usage['bytes'],
                             usage['bytes_limit']))
      except Exception as e:
        logLine('Failed replacing storage quota for %s/%s: %s' %
                (namedQuotaRow['quota_name'], usage['rse'], str(e)))

  try:
    justin.insertUpdate('DELETE FROM storages_quotas '
                        'WHERE last_seen_time < '
                        'DATE_SUB(NOW(),INTERVAL 24 HOUR)')
  except Exception as e:
    logLine('Failed removing old storages_quotas entries: ' + str(e))
                            
  justin.conn.commit()

def updateLogsDatasets():
  # Ensure that logs datasets exists for each RSE
  # like justin-logs:logstgz-1710000000-MANCHESTER
  logLine('---- Start updateLogsDatasets ----')

  try:
    rseRows = justin.select('SELECT rse_id,rse_name FROM storages '
                            'WHERE NOT decommissioned AND rse_id<>%d AND '
                            'rucio_write AND justin_write'
                            % justin.MonteCarloRseID)
  except:
    logLine('Failed to get list of RSEs')
    return
  
  try:
    logLine('Try to create DID and Rule Rucio clients')
    didClient  = rucio.client.didclient.DIDClient()
    ruleClient = rucio.client.ruleclient.RuleClient()
  except Exception as e:
    logLine("Connect to Rucio fails with: " + str(e))
    return

  periodStartTime = 1000000 * int(time.time() / 1000000)
  
  for t in range(periodStartTime, periodStartTime + 2000001, 1000000):
    for rseRow in rseRows:
      datasetName = 'logstgz-%d-%s' % (t, rseRow['rse_name'])

      try:
        didClient.get_did('justin-logs',datasetName)

      except rucio.common.exception.DataIdentifierNotFound:
        logLine('justin-logs:%s does not yet exist - creating' % datasetName)
        executeMetaCatCommand('dataset create justin-logs:%s' % datasetName)
        try:
          didClient.add_dataset(scope = 'justin-logs', name = datasetName)
        except Exception as e:
          logLine('Failed creating dataset justin-logs:%s - %s'
                  % (datasetName, str(e)))
          continue

      except:
        logLine('Failed checking if justin-logs:%s exists' % datasetName)
        continue

      try:
        l = list(ruleClient.list_replication_rules({'scope' : 'justin-logs',
                                                    'name'  : datasetName   }))
      except:
        l = []

      if len(l) == 0:
        try:
          ruleClient.add_replication_rule(
                     dids = [ {'scope' : 'justin-logs',
                               'name'  : datasetName} ], 
                     copies = 1, 
                     rse_expression = rseRow['rse_name'],
                     lifetime = 4000000)
        except Exception as e:
          logLine('Failed creating rule for justin-logs:%s - %s'
                  % (datasetName, str(e)))

# Make sure HTCondor accounting groups are in database
def updateGroupsHTCondor():
  logLine('---- Start updateGroupsHTCondor ----')
  
  try: 
    outcome = subprocess.run(
               ['/usr/bin/condor_userprio',
                '-pool',
                justin.htcondorCollectors[0],
                '-quotas',
                '-allusers'
               ],
               env      = dict(os.environ, 
                 BEARER_TOKEN_FILE='/etc/justin-secrets/bearer-token-file'),
               encoding = 'utf-8',
               stderr   = subprocess.STDOUT,
               stdout   = subprocess.PIPE,
               timeout  = 60
                            ) 

    lines = outcome.stdout.splitlines()
  except Exception as e:
    logLine("condor_userprio fails with error: " + str(e))
    return

  logLine('condor_userprio exit code: ' + str(outcome.returncode))

  for line in lines:
    try:
      (groupName, effQuota, confQuota, surplus, subtreeQuota, weighted) \
        = line.split()
    except:
      groupName = ''

    if groupName.startswith('group_dune') and justin.stringNoQuotes(groupName):
      logLine('Checking Condor Group %s is in database' % groupName)
      try:
        rows = justin.select('SELECT condor_group_id FROM condor_groups '
                             'WHERE condor_group_name="%s"' % groupName)
        if len(rows) == 0:
          # Not there yet, so add
          try:
            justin.insertUpdate('INSERT INTO condor_groups '
                                'SET condor_group_name="%s"' % groupName)
          except Exception as e:
            logLine('Failed inserting Condor Group %s : %s'
                  % (groupName, str(e)))

      except Exception as e:
        logLine('Failed finding Condor Group %s in database : %s'
                % (groupName, str(e)))
      
      try:
        justin.insertUpdate('UPDATE condor_groups SET config_quota=%s,'
                            'effective_quota=%s '
                            'WHERE condor_group_name="%s"' % 
                            (confQuota, effQuota, groupName))
      except Exception as e:
        logLine('Failed updating Condor Group %s : %s' % (groupName, str(e)))
                            

# Make sure WLCG groups in config are in database
def updateGroupsWLCG():
  logLine('---- Start updateGroupsWLCG ----')

  for groupName in justin.wlcgGroups:
    logLine('Checking WLCG Group %s is in database' % groupName)
    try:
      rows = justin.select('SELECT wlcg_group_id FROM wlcg_groups '
                          'WHERE wlcg_group_name="%s"' % groupName)
      if len(rows) == 0:
        # Not there yet, so add
        try:
          justin.insertUpdate('INSERT INTO wlcg_groups '
                              'SET wlcg_group_name="%s"' % groupName)
        except Exception as e:
          logLine('Failed inserting WLCG Group %s : %s'
                  % (groupName, str(e)))

    except Exception as e:
      logLine('Failed finding WLCG Group %s in database : %s'
              % (groupName, str(e)))

def updateScopes():
  # Get info about scopes Rucio knows about
  logLine('---- Start updateScopes ----')

  # Set up for Rucio queries
  try:
    scopeClient = rucio.client.scopeclient.ScopeClient()
  except Exception as e:
    logLine("Connect to Rucio fails with: " + str(e))
    return

  # Make a list of scopes we already know
  justinScopes = {}
  try:
    justinScopeRows = justin.select('SELECT scope_name,condor_group_id,'
                                    'quota_id FROM scopes')
  except Exception as e:
    logLine('Failed to get names of existing justIN scopes')
    return
    
  for justinScopeRow in justinScopeRows:
    justinScopes[justinScopeRow['scope_name']] = \
     {
       'condor_group_id' : justinScopeRow['condor_group_id'],
       'quota_id'        : justinScopeRow['quota_id']
     }

  # Go through all the named quotas / Rucio users we know justIN can access
  try:
    justinQuotaRows = justin.select(
               'SELECT quota_name,quota_id,wlcg_group_id,'
               'condor_group_id '
               'FROM named_quotas WHERE for_justin')
  except Exception as e:
    logLine('Failed to get names of existing justIN Rucio users')
    return
    
  for justinQuotaRow in justinQuotaRows:
# REMOVE THE usertests HANDLING ONCE EVERYONE HAS A PERSONAL QUOTA
    if justinQuotaRow['quota_name'] == 'usertests':
      scopesForUser = ['usertests']
    else:
      # Find the scopes owned by each Rucio user accessible to justIN
      try:
        scopesForUser = scopeClient.list_scopes_for_account(
                                   justinQuotaRow['quota_name'])
      except Exception as e:
        logLine("Reading scopes list from Rucio fails with: " + str(e))
        continue

    for scopeForUser in scopesForUser:
    
# REMOVE THE usertests HANDLING ONCE EVERYONE HAS A PERSONAL QUOTA
      if scopeForUser == 'usertests' and \
         justinQuotaRow['quota_name'] != 'usertests':         
        # Skip if usertests as a dunepro scope
        continue
    
      if scopeForUser not in justinScopes:
        # A new scope we need to add!
        logLine('Adding new scope %s from Rucio' % scopeForUser)

        try:
          justin.insertUpdate('INSERT INTO scopes SET scope_name="%s",'
                              'quota_id=%d,condor_group_id=%d' %
                              (scopeForUser, 
                               justinQuotaRow['quota_id'],
                               justinQuotaRow['condor_group_id']))
        except Exception as e:
          logLine('Failed to insert new scope %s into justIN database: %s'
                % (scopeForUser, str(e)))
          continue

      elif ((justinScopes[scopeForUser]['quota_id'] 
             != justinQuotaRow['quota_id'])
            or (justinScopes[scopeForUser]['condor_group_id'] == 0)):
        # An existing scope we need to update
        logLine('Update scope %s' % scopeForUser)

        if justinScopes[scopeForUser]['condor_group_id'] == 0:
          # Set it to the quota's default if not already set
          condorGroupID = justinQuotaRow['condor_group_id']
        else:
          # Keep it if already set
          condorGroupID = justinScopes[scopeForUser]['condor_group_id']
        
        try:
          justin.insertUpdate('UPDATE scopes SET '
                              'quota_id=%d,condor_group_id=%d '
                              'WHERE scope_name="%s"' %
                              (justinQuotaRow['quota_id'],
                               condorGroupID,
                               scopeForUser))
        except Exception as e:
          logLine('Failed to update scope %s in justIN database: %s'
                % (scopeForUser, str(e)))
          continue        

  justin.conn.commit()

def updateNamedQuotas():
  # Get info about named quotas / users Rucio knows about
  logLine('---- Start updateNamedQuotas ----')

  try:
    row = justin.select('SELECT condor_group_id FROM condor_groups '
                        'WHERE condor_group_name="group_dune"', justOne = True)
    duneCondorGroupID = int(row['condor_group_id'])

  except Exception as e:
    logLine('Failed getting group_dune Condor group ID: ' + str(e))
    return

  try:
    row = justin.select('SELECT wlcg_group_id FROM wlcg_groups '
                        'WHERE wlcg_group_name="/dune"', justOne = True)
    duneWLCGGroupID = int(row['wlcg_group_id'])

  except Exception as e:
    logLine('Failed getting /dune WLCG group ID: ' + str(e))
    return

  # Make a dictionary of Rucio user names we already have in the database
  justinQuotaNames = {}
  try:
    justinQuotaRows = justin.select('SELECT quota_name,user_id,'
                                    'wlcg_group_id FROM named_quotas')
  except Exception as e:
    logLine('Failed to get names of existing justIN named quotas / Rucio users')
    return
    
  for justinQuotaRow in justinQuotaRows:
    justinQuotaNames[justinQuotaRow['quota_name']] = \
     { 'user_id'       : justinQuotaRow['user_id'],
       'wlcg_group_id' : justinQuotaRow['wlcg_group_id'] }

#  logLine('quota names: ' + str(justinQuotaNames))

  # TO BE REMOVED ONCE ALL USERS HAVE PERSONAL NAMED QUOTAS
  # Make sure the usertests quota is there
  if 'usertests' not in justinQuotaNames:
    try:
      justin.insertUpdate('INSERT INTO named_quotas SET '
                          'quota_name="usertests",wlcg_group_id=%d,'
                          'condor_group_id=%d,processing_enabled=1,'
                          'for_justin=1' 
                          % (duneWLCGGroupID, duneCondorGroupID))
    except Exception as e:
      logLine('Failed to insert usertests named quota: ' + str(e))

  # Make a dictionary of all the justIN users in the database
  justinUnderscoreNames = {}

  try:
    justinPrincipalNameRows = justin.select('SELECT principal_name,user_id '
                                            'FROM principal_names')
  except Exception as e:
    logLine('Failed to get names of existing justIN Rucio users')
    return
    
  for justinPrincipalNameRow in justinPrincipalNameRows:  
    nameUnderscores = re.sub('[^0-9a-zA-Z]+', '_',
                            justinPrincipalNameRow['principal_name'])
    justinUnderscoreNames[nameUnderscores] = justinPrincipalNameRow['user_id']

#  logLine('underscore names: ' + str(justinUnderscoreNames))

  # Look for new user names in Rucio itself
  try:
    accountClient = rucio.client.accountclient.AccountClient()
  except Exception as e:
    logLine("Connect to Rucio fails with: " + str(e))
    return
    
  try:
    rucioUsers = accountClient.list_accounts()
  except Exception as e:
    logLine("Reading accounts list from Rucio fails with: " + str(e))
    return

  for rucioUser in rucioUsers:
    if rucioUser['account'] not in justinQuotaNames:
      # We do not know this one - need to add it
      logLine('New Rucio user %s' % rucioUser['account'])

      # Check if justIN can access this account
      try:
        userIdentities = accountClient.list_identities(rucioUser['account'])
      except Exception as e:
        logLine("Reading identities list from Rucio fails with: " + str(e))
        return
    
      forJustIN = False
      for userIdentity in userIdentities:
# REMOVE THE amcnab EXCEPTION ONCE IT NO LONGER HAS THE PRODUCTION
# X509 CERTIFICATE DN! 
        if userIdentity['type'] == 'X509' and \
             userIdentity['identity'] == justin.productionDN and \
             rucioUser['account'] != 'amcnab':
          forJustIN = True
          break
    
      if rucioUser['account'] in justinUnderscoreNames:
        # If there is a corresponding justIN user, store its user_id
        storedUserID = justinUnderscoreNames[rucioUser['account']]
      else:
        storedUserID = 0
    
      try:
        justin.insertUpdate('INSERT INTO named_quotas '
                            'SET quota_name="%s",user_id=%d,'
                            'condor_group_id=%d,for_justin=%s'
                            % (rucioUser['account'], storedUserID, 
                               duneCondorGroupID, forJustIN))
        logLine('Added Rucio user %s' % rucioUser['account'])
      except Exception as e:
        logLine('Failed to insert new Rucio user %s into database: %s'
                % (rucioUser['account'], str(e)))
        # We just continue if this one fails
        continue
    
    elif rucioUser['account'] in justinUnderscoreNames:
      # We know the Rucio account and there is a corresponding justIN user
      logLine('Check %s for updates' % rucioUser['account'])

      # Recheck if justIN can access this account to set for_justin
      try:
        userIdentities = accountClient.list_identities(rucioUser['account'])
      except Exception as e:
        logLine("Reading identities list from Rucio fails with: " + str(e))
        continue
    
      forJustIN = False
      for userIdentity in userIdentities:
        if userIdentity['type'] == 'X509' and \
             userIdentity['identity'] == justin.productionDN:
          forJustIN = True
          break
      
      try:
        justin.insertUpdate('UPDATE named_quotas '
                            'SET user_id=%d,wlcg_group_id=0,for_justin=%s '
                            'WHERE quota_name="%s"'
                  % (justinQuotaNames[rucioUser['account']]['user_id'],
                     forJustIN,
                     rucioUser['account']))
        logLine('Update Rucio user %s' % rucioUser['account'])
      except Exception as e:
        logLine('Failed to update Rucio user %s in database: %s'
                   % (rucioUser['account'], str(e)))
        # We just continue if this one fails
        continue

#    elif justinQuotaNames[rucioUser['account']]['wlcg_group_id']:
#      # We know the Rucio account and the wlcg_group_id is set (they have
#      # to be set manually at the moment)
    else:
      # Recheck if justIN can access this account to set for_justin
      try:
        userIdentities = accountClient.list_identities(rucioUser['account'])
      except Exception as e:
        logLine("Reading identities list from Rucio fails with: " + str(e))
        continue
    
      forJustIN = False
      for userIdentity in userIdentities:
        if userIdentity['type'] == 'X509' and \
             userIdentity['identity'] == justin.productionDN:
          forJustIN = True
          break
      
      try:
        # Set for_justin and ensure user_id is zero for this group account
        justin.insertUpdate('UPDATE named_quotas '
                            'SET user_id=0,for_justin=%s '
                            'WHERE quota_name="%s"'
                  % (forJustIN, rucioUser['account']))
        logLine('Update Rucio user %s' % rucioUser['account'])
      except Exception as e:
        logLine('Failed to update Rucio user %s in database: %s'
                 % (rucioUser['account'], str(e)))
        # We just continue if this one fails
        continue

  justin.conn.commit()

def oneCycle():

  # Is it time to test Rucio
  try:
    lastTestRucio \
             = os.stat('/var/run/justin/last-updates/test-rucio').st_mtime
  except:
    lastTestRucio = 0

  if lastTestRucio + testRucioInterval < time.time():
    pathlib.Path('/var/run/justin/last-updates/test-rucio').touch(exist_ok=True)
    testRucio()

  # Is it time to update CILogon Jwks
  try:
    lastUpdateJwks = os.stat('/var/run/justin/last-updates/jwks').st_mtime
  except:
    lastUpdateJwks = 0

  if lastUpdateJwks + updateJwksInterval < time.time():
    pathlib.Path('/var/run/justin/last-updates/jwks').touch(exist_ok=True)
    updateJwks()

  # Is it time to update storages from Rucio?
  try:
    lastUpdateStorages = os.stat('/var/run/justin/last-updates/storages').st_mtime
  except:
    lastUpdateStorages = 0

  if lastUpdateStorages + updateStoragesInterval < time.time():
    pathlib.Path('/var/run/justin/last-updates/storages').touch(exist_ok=True)
    updateGroupsHTCondor()
    updateGroupsWLCG()
    updateStorages()
    updateLogsDatasets()
    updateNamedQuotas()
    updateScopes()
    updateStoragesQuotas()

  # It is time to update sites from the OSG pilot factory config?
  try:
    lastUpdateSites = os.stat('/var/run/justin/last-updates/sites').st_mtime
  except:
    lastUpdateSites = 0

  if lastUpdateSites + updateSitesInterval < time.time():
    pathlib.Path('/var/run/justin/last-updates/sites').touch(exist_ok=True)
    updateSites()
    updateSitesStorages()

  justin.conn.commit()

#
# PROGRAM MAIN
#

if __name__ == '__main__':
  justin.agentMainLoop('info-collector', oneCycle, sleepSeconds, 3600)
