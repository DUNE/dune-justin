#
# justin-wsgi-commands - justIN commands API service
#
# Copyright 2013-23, Andrew McNab for the University of Manchester
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# This WSGI script relies on justin-api-import-script being run by
# the mod_wsgi directive WSGIImportScript

# This WSGI script must be run from an Apache httpd server with
# X.509 proxy certificates enabled. On a systemd system (like 
# CentOS 7) you need to enable this in OpenSSL inside mod_ssl
# by adding this line to /usr/lib/systemd/system/httpd.service
# in the [Service] section:
#
# Environment=OPENSSL_ALLOW_PROXY_CERTS=1

import os
import re
import sys
import time
import json
import string
import datetime

import justin

def httpError(startResponse, code, message):

  justin.db.conn.rollback()

  print('justin-wsgi-commands fails with %s (%s)' % 
        (code, str(message)), file=sys.stderr)

  startResponse(code,
                [('Content-type',   'text/plain'),
                 ('Content-length', str(len(message)))
                ])

  return [(message + '\n').encode('UTF-8')]
  
def httpOK(startResponse, outputString):

  justin.db.conn.commit()
  startResponse('200 OK',
                [('Content-type',   'text/plain'),
                 ('Content-length', str(len(outputString)))
                ])

  return [outputString.encode('UTF-8')]
  
def timeCmd(startResponse):

  return httpOK(startResponse, 
                datetime.datetime.today().strftime('%Y-%m-%d %H:%M:%S UTC\n'))

def showRequestsCmd(startResponse, jsonDict):

  try:
    requestID = int(jsonDict['request_id'])
  except:
    requestID    = None
    requestFilter = ""
  else:
    requestFilter = "WHERE request_id=" + str(requestID)

  try:
    rows = justin.db.select("SELECT * FROM requests %s ORDER BY created" 
                         % requestFilter)
  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error reading justIN database ' + str(e))

  outputString = ''
  for row in rows:
    outputString += ("%5d %-9s %s %s %s\n" % 
                     (row['request_id'], row['state'],
                      row['created'], row['description'], row['mql']))

  return httpOK(startResponse, outputString)

def showStagesCmd(startResponse, jsonDict):

  try:
    requestID = int(jsonDict['request_id'])
  except:
    return httpError(startResponse, '400 Bad Request', 'Request ID not given')

  try:
    stageID = int(jsonDict['stage_id'])
  except:
    stageID    = None
    stageFilter = ""
  else:
    stageFilter = "AND stage_id=" + str(stageID)

  try:
    rows = justin.db.select("SELECT * FROM stages WHERE request_id=%d %s "
                         "ORDER BY request_id,stage_id" 
                         % (requestID, stageFilter))
  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error reading justIN database ' + str(e))

  outputString = ''
  for row in rows:
    outputString += ("%5d %2d %d %d %d %.1f\n" % 
                     (row['request_id'], 
                      row['stage_id'], 
                      row['processors'],
                      row['wall_seconds'],
                      row['rss_bytes'],
                      row['max_distance'],
                    ))

  return httpOK(startResponse, outputString)

def showJobscriptCmd(startResponse, jsonDict):

  try:
    jsid = jsonDict['jobscript_id'].lower()
  except:
    jsid = None

  try:
    requestID = int(jsonDict['request_id'])
  except:
    requestID = 0

  try:
    stageID = int(jsonDict['stage_id'])
  except:
    stageID = 0

  if (jsid and (requestID or stageID)) or \
     (not jsid and (not requestID or not stageID)):
    return httpError(startResponse,
                     '400 Bad Request', 
          '--jobscript-id OR --request-id/--stage-id must be given')

  if jsid:
    # From Jobscripts Library with JSID
    response = justin.lookupJobscript(jsid)
    
    if response['error']:
      return httpError(startResponse,
                       '400 Bad Request', 
                       response['error'])
      
    jobscript = response['jobscript']

  else:
    # From stage with requestID and stageID
    query = ('SELECT jobscript FROM stages_jobscripts '
             'WHERE request_id=%d AND stage_id=%d'
             % (requestID, stageID))
  
    try:
      row = justin.db.select(query, justOne = True)
      jobscript = row['jobscript']
    except Exception as e:
      return httpError(startResponse, 
                      '500 Internal Server Error', 
                      'Error reading justIN database ' + str(e))

  if not jobscript.endswith('\n'):
    jobscript += '\n'

  return httpOK(startResponse, jobscript)

def showStageOutputsCmd(startResponse, jsonDict):

  try:
    requestID = int(jsonDict['request_id'])
  except:
    return httpError(startResponse, '400 Bad Request', 'Request ID not given')

  try:
    stageID = int(jsonDict['stage_id'])
  except:
    return httpError(startResponse, '400 Bad Request', 'Stage ID not given')

  try:
    rows = justin.db.select("SELECT * FROM stages_outputs "
                         "WHERE request_id=%d AND stage_id=%d "
                         "ORDER BY dataset,file_scope,file_pattern" 
                         % (requestID, stageID))
  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error reading justIN database ' + str(e))

  outputString = ''
  for row in rows:
    nextStage = '(next)' if row['for_next_stage'] else '(    )'
    outputString += ("%s %s %s %s\n" % (nextStage,
                                        row['dataset'],
                                        row['file_scope'],
                                        row['file_pattern']))
   
  return httpOK(startResponse, outputString)

def showFilesCmd(startResponse, jsonDict):

  try:
    requestID = int(jsonDict['request_id'])
  except:
    requestID = None

  try:
    stageID = int(jsonDict['stage_id'])
  except:
    stageID = None

  try:
    fileDID = jsonDict['file_did']
  except:
    fileDID = None

  if fileDID is None and requestID is None:
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'Either file DID or request ID must be given')

  if fileDID and not requestID:
    filter = "file_did='%s'" % fileDID
  elif requestID:
    filter = "request_id=%d" % requestID
    
    if stageID:
      filter += " AND stage_id=%d" % stageID
    
    if fileDID:
      filter += " AND file_did='%s'" % fileDID

  try:
    rows = justin.db.select("SELECT * FROM files WHERE " + filter +
                         " ORDER BY request_id,stage_id,file_did")
  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error reading justIN database ' + str(e))

  outputString = ''
  for row in rows:
    outputString += ("%5d %2d %-11s %s\n" % 
                     (row['request_id'],
                      row['stage_id'],
                      row['state'],
                      row['file_did'],
                     )
                    )
   
  return httpOK(startResponse, outputString)

def showReplicasCmd(startResponse, jsonDict):

  try:
    requestID = int(jsonDict['request_id'])
  except:
    requestID = None

  try:
    stageID = int(jsonDict['stage_id'])
  except:
    stageID = None

  if 'file_did' in jsonDict and jsonDict['file_did']:
    fileDID = jsonDict['file_did']
  else:
    fileDID = None

  try:
    rseName = re.sub('[^A-Za-z0-9._-]+', '', str(jsonDict['rse_name'][0]))
  except:
    rseName = None
    
  if fileDID is None and requestID is None:
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'Either file DID or request ID must be given')

  if fileDID and not requestID:
    filter = "files.file_did='%s'" % fileDID
  elif requestID:
    filter = "files.request_id=%d" % requestID
    
    if stageID:
      filter += " AND files.stage_id=%d" % stageID
    
    if fileDID:
      filter += " AND files.file_did='%s'" % fileDID

  if rseName:
    filter += " AND storages.rse_name='%s'" % rseName

  try:
    rows = justin.db.select("SELECT replicas.request_id,replicas.stage_id,"
                         "files.state,"
                         "storages.rse_name,files.file_did "
                 "FROM replicas "
                 "LEFT JOIN storages ON replicas.rse_id=storages.rse_id "
                 "LEFT JOIN files ON replicas.file_id=files.file_id "
                 "WHERE " + filter + " ORDER BY "
                 "files.request_id,files.stage_id,files.file_did")
  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error reading justIN database ' + str(e))

  outputString = ''
  for row in rows:
    outputString += ("%5d %2d %-11s %-15s %s\n" % 
                     (row['request_id'],
                      row['stage_id'],
                      row['state'],
                      row['rse_name'],           
                      row['file_did']
                     )
                    )
   
  return httpOK(startResponse, outputString)

def showStoragesCmd(startResponse, jsonDict):

  try:
    rseName = re.sub('[^A-Za-z0-9._-]+', '', str(jsonDict['rse_name'][0]))
    filter  = "WHERE rse_name='%s'" % rseName
  except:
    filter = ""

  try:
    rows = justin.db.select("SELECT rse_name,"
                         "occupancy,"
                         "rucio_write,"
                         "rucio_read,"
                         "justin_write,"
                         "justin_read,"
                         "(rucio_write AND justin_write) AS has_write,"
                         "(rucio_read AND justin_read) AS has_read "
                         "FROM storages " + filter + 
                         " ORDER BY rse_name,occupancy")
  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error reading justIN database ' + str(e))

  outputString = ''
  for row in rows:
    outputString += ("%-25s %.2f  %s=%s%s %s=%s%s\n" % 
                     (row['rse_name'], 
                      row['occupancy'],
                      'R' if row['has_read']    else '-',
                      'R' if row['rucio_read']  else '-',
                      'R' if row['justin_read']    else '-',
                      'W' if row['has_write']   else '-',
                      'W' if row['rucio_write'] else '-',
                      'W' if row['justin_write']   else '-'))

  return httpOK(startResponse, outputString)

def showSitesStoragesCmd(startResponse, jsonDict):

  if 'site_name' in jsonDict and jsonDict['site_name']:
    siteName = jsonDict['site_name']
  else:
    siteName = None

  try:
    rseName = re.sub('[^A-Za-z0-9._-]+', '', str(jsonDict['rse_name'][0]))
  except:
    rseName = None
    
  if siteName and rseName:
    filter = "WHERE site_name='%s' AND rse_name='%s'" % (siteName, rseName)
  elif siteName:
    filter = "WHERE site_name='%s'" % siteName
  elif rseName:
    filter = "WHERE rse_name='%s'" % rseName
  else:
    filter = ""

  try:
    rows = justin.db.select("SELECT * FROM sites_storages " 
                "LEFT JOIN storages ON sites_storages.rse_id=storages.rse_id "
                "LEFT JOIN sites ON sites_storages.site_id=sites.site_id "
                + filter +          
                " ORDER BY site_name,rse_name")
  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error reading justIN database ' + str(e))

  outputString = ''
  for row in rows:
    outputString += ("%-20s %-22s %5.1f\n" % 
                     (row['site_name'], row['rse_name'],
                      row['distance']))
   
  return httpOK(startResponse, outputString)

def createRequestCmd(startResponse, jsonDict, userID):

  if 'description' in jsonDict and jsonDict['description']:
    description = jsonDict['description']
  else:
    description = ''

  if 'mql' in jsonDict and jsonDict['mql']:
    mql = jsonDict['mql']
  else:
    mql = ''

  if 'monte_carlo' in jsonDict and jsonDict['monte_carlo']:
    try:
      mql = 'monte-carlo %d' % int(jsonDict['monte_carlo'])
    except:
      return httpError(startResponse, 
                       '400 Bad Request', 
                       'Monte Carlo option requires an integer count')

  if 'refind_interval_hours' in jsonDict and jsonDict['refind_interval_hours']:
    try:
      refindIntervalSeconds = int(jsonDict['refind_interval_hours'] * 3600)
    except:
      return httpError(startResponse, 
                       '400 Bad Request', 
                       '--refind-interval-hours requires an integer argument')
  else:
    refindIntervalSeconds = 0

  if 'refind_start_date' in jsonDict and jsonDict['refind_start_date']:
    try:
      yyyymmdd = str(int(jsonDict['refind_start_date']))
      refindStartDate = '%s-%s-%s 00:00:00' % (yyyymmdd[0:4], 
                                               yyyymmdd[4:6], 
                                               yyyymmdd[6:8])
    except:
      return httpError(startResponse, 
                       '400 Bad Request', 
                       '--refind-start-date requires a YYYYMMDD date')
  else:
    refindStartDate = datetime.datetime.today().strftime('%Y-%m-%d 00:00:00')

  if 'refind_duration_days' in jsonDict and jsonDict['refind_duration_days']:
    try:
      refindDurationDays = int(jsonDict['refind_duration_days'])
      refindFinishDate = (
                          datetime.datetime.today() +
                          datetime.timedelta(refindDurationDays)
                         ).strftime('%Y-%m-%d 23:59:59')
    except:
      return httpError(startResponse,
                       '400 Bad Request', 
                       '--refind-duration-days requires an integeer')
  else:
    refindDurationDays = 1

  try:
    requestID = justin.db.insertUpdate('INSERT INTO requests SET created=NOW(),'
          'description="%s",'
          'mql="%s",'
          'user_id=%d,'
          'refind_seconds=%d,'
          'refind_start_time="%s",'
          'refind_end_time="%s"' %
          (description,
           mql,
           userID,
           refindIntervalSeconds,
           refindStartDate,
           refindFinishDate))
  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error updating justIN database ' + str(e))

  return httpOK(startResponse, str(requestID) + '\n')

def quickRequestCmd(startResponse, jsonDict, userID):

  if 'description' in jsonDict and jsonDict['description']:
    description = jsonDict['description']
  else:
    description = ''

  if 'mql' in jsonDict and jsonDict['mql']:
    mql = jsonDict['mql']
  else:
    mql = ''

  if 'max_distance' in jsonDict and jsonDict['max_distance']:
    try:
      maxDistance = float(jsonDict['max_distance'])
    except:
      return httpError(startResponse, 
                       '400 Bad Request',
                       '--max-distance option requires a numeric distance')
  else:
    maxDistance = 0.0

  if 'max_files_per_job' in jsonDict and jsonDict['max_files_per_job']:
    try:
      maxFilesPerJob = int(jsonDict['max_files_per_job'])
    except:
      return httpError(startResponse, 
                       '400 Bad Request', 
                       '--max-files-per-job option requires an integer')
  else:
    maxFilesPerJob = 1

  if 'monte_carlo' in jsonDict and jsonDict['monte_carlo']:
    try:
      mql = 'monte-carlo %d' % int(jsonDict['monte_carlo'])
      maxDistance = 100.0
    except:
      return httpError(startResponse, 
                       '400 Bad Request', 
                       'Monte Carlo option requires an integer count')
      
  if 'refind_hours' in jsonDict and jsonDict['refind_hours']:
    try:
      refindSeconds = int(jsonDict['refind_hours'] * 3600)
    except:
      return httpError(startResponse, 
                       '400 Bad Request', 
                       '--refind-hours requires an integer argument')
  else:
    refindSeconds = 0

  if 'refind_start' in jsonDict and jsonDict['refind_start']:
    try:
      yyyymmdd = str(int(jsonDict['refind_start']))
      refindStart = '%s-%s-%s 00:00:00' % (yyyymmdd[0:4], 
                                           yyyymmdd[4:6], 
                                           yyyymmdd[6:8])
    except:
      return httpError(startResponse, 
                       '400 Bad Request', 
                       '--refind-start requires a YYYYMMDD date')
  else:
    refindStart = datetime.datetime.today().strftime('%Y-%m-%d 00:00:00')

  if 'refind_end' in jsonDict and jsonDict['refind_end']:
    try:
      yyyymmdd = str(int(jsonDict['refind_end']))
      refindEnd = '%s-%s-%s 00:00:00' % (yyyymmdd[0:4], 
                                         yyyymmdd[4:6], 
                                         yyyymmdd[6:8])
    except:
      return httpError(startResponse, 
                       '400 Bad Request', 
                       '--refind-end requires a YYYYMMDD date')
  else:
    refindEnd = datetime.datetime.today().strftime('%Y-%m-%d 23:59:59')
      

  try:
    requestID = justin.db.insertUpdate('INSERT INTO requests SET created=NOW(),'
          'submitted=NOW(),'
          'started=NOW(),'
          'state="running",'
          'description="%s",'
          'mql="%s",'
          'user_id=%d,'
          'refind_seconds=%d,'
          'refind_start_time="%s",'
          'refind_end_time="%s"' %
          (description,
           mql,
           userID,
           refindSeconds,
           refindStart,
           refindEnd))
  except Exception as e:
    return httpError(startResponse, '500 Internal Server Error',
                     'Error updating justIN database ' + str(e))

  try:
    processors = int(jsonDict['processors'])
  except:
    processors = 1

  try:
    wallSeconds = int(jsonDict['wall_seconds'])
  except:
    wallSeconds = 80000

  try:
    rssBytes = int(jsonDict['rss_mb']) * 1024 * 1024
  except:
    rssBytes = 2000 * 1024 * 1024

  jobscriptID = 0

  try:
    jobscript = jsonDict['jobscript']
  except:
    jobscript = None

  if not jobscript:
    try:
      jsid = jsonDict['jobscript_id']
    except:
      jsid = None

    if not jsid:
      return httpError(startResponse, '400 Bad Request',
                       '--jobscript or --jobscript-id must by given')

    response = justin.lookupJobscript(jsid)
    if response['error']:
      return httpError(startResponse, '400 Bad Request', response['error'])

    jobscript   = response['jobscript']
    jobscriptID = response['jobscript_id']

  if 'scope' in jsonDict and jsonDict['scope']:
    # --scope option given, so check the scope is known
    scopeName = jsonDict['scope'].lower()

    if not justin.db.stringIsDomain(scopeName):
      return httpError(startResponse,
                       '400 Bad Request', 
                       'Scope name can only be characters a-z 0-9 - _ .')

    try:
      scopeRow = justin.db.select('SELECT scope_id FROM scopes '
                                  'WHERE scope_name="%s"' % scopeName, 
                                  justOne=True)
      scopeID = int(scopeRow['scope_id'])
    except:
      return httpError(startResponse,
                       '400 Bad Request', 
                       'Failed to find scope %s in justIN database' % scope)
  else:
    scopeName = None
    scopeID   = 0

  try:
    justin.db.insertUpdate("INSERT INTO stages SET "
          "stage_rank=0,"
          "request_id=%d,"
          "stage_id=1,"
          "scope_id=%d,"
          "jobscript_id=%d,"
          "processors=%d,"
          "wall_seconds=%d,"
          "rss_bytes=%d,"
          "max_distance=%f,"
          "max_files_per_job=%d" 
          % (requestID, scopeID, jobscriptID, processors,
             wallSeconds, rssBytes, maxDistance, maxFilesPerJob))
          
    justin.db.insertUpdate('INSERT INTO stages_jobscripts SET '
          'request_id=%d,'
          'stage_id=1,'
          'jobscript="%s"' % 
          (requestID, 
           jobscript.replace('\\','\\\\').replace('"','\\"')))
  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error updating justIN database ' + str(e))

  try:
    lifetimeDays = int(jsonDict['lifetime_days'])
  except:
    lifetimeDays = 1

  if (jsonDict['output_pattern'] or jsonDict['output_pattern_next_stage']) \
     and not scopeName:
    return httpError(startResponse, 
                     '400 Bad Request', 
                     '--scope must by given too for --output_pattern and '
                     '--output_pattern_next_stage')

  if jsonDict['output_pattern']:
    for i in jsonDict['output_pattern']:
      splitList = i.split(':')
       
      if len(splitList) < 2:
        continue
    
      datasetName  = splitList[0]
      pattern      = ':'.join(splitList[1:])

      try:
        justin.db.insertUpdate('INSERT INTO stages_outputs SET '
              'request_id=%d,'
              'stage_id=1,'
              'dataset="%s:%s",'
              'file_pattern="%s",'
              'lifetime_seconds=%d,'
              'for_next_stage=FALSE' % 
              (requestID,
               scopeName, datasetName.replace('\\','\\\\').replace('"','\\"'),
               pattern.replace('\\','\\\\').replace('"','\\"'),
               lifetimeDays * 86400
              )
             )
      except Exception as e:
        return httpError(startResponse, 
                        '500 Internal Server Error', 
                        'Error updating justIN database ' + str(e))

  if jsonDict['output_rse']:
    for rseName in jsonDict['output_rse']:
    
      if not justin.db.stringIsSite(rseName):
        return httpError(startResponse, '400 Bad Request', 'Invalid RSE name')

      try:
        justin.db.insertUpdate('INSERT INTO stages_output_storages SET '
              'request_id=%d,'
              'stage_id=1,'
              'rse_id=(SELECT rse_id FROM storages WHERE rse_name="%s")' % 
              (requestID, rseName))
      except Exception as e:
        return httpError(startResponse, 
                         '500 Internal Server Error', 
                          'Error updating justIN database ' + str(e))

  if jsonDict['env']:
    for envNameValue in jsonDict['env']:    
      try:        
        (envName,envValue) = envNameValue.split('=',1)
      except:
        return httpError(startResponse,
                         '400 Bad Request',
                         'Failed to parse --env option')

      if not justin.db.stringIsEnvName(envName):
        return httpError(startResponse, 
                         '400 Bad Request', 
                         'Invalid environment variable name')

      try:
        justin.db.insertUpdate('INSERT IGNORE INTO stages_environment SET '
              'request_id=%d,'
              'stage_id=1,'
              'env_name="%s",'
              'env_value="%s"' % 
              (requestID, 
               envName, 
               envValue.replace('\\','\\\\').replace('"','\\"')
              ))

      except Exception as e:
        return httpError(startResponse, 
                         '500 Internal Server Error', 
                         'Error updating justIN database ' + str(e))

  return httpOK(startResponse, str(requestID) + '\n')

def submitRequestCmd(startResponse, jsonDict):

  try:
    requestID = int(jsonDict['request_id'])
  except:
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'Request ID must be given')

# change to handle errors properly eg no such request
# and state not draft
  try:
    justin.db.insertUpdate("UPDATE requests SET "
                        "state='submitted',submitted=NOW() "
                        "WHERE request_id=%d AND state='draft'" % requestID)
  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error updating justIN database ' + str(e))

  return httpOK(startResponse, '')

def startRequestCmd(startResponse, jsonDict):

  try:
    requestID = int(jsonDict['request_id'])
  except:
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'Request ID must be given')

# change to handle errors properly eg no such request
# or not in draft or submitted states
  try:
    justin.db.insertUpdate("UPDATE requests SET started=NOW() "
          "WHERE request_id=%d AND "
          "(state='draft' OR state='submitted')"
          % requestID)

    justin.db.insertUpdate("UPDATE requests SET state='running' "
          "WHERE request_id=%d AND "
          "(state='draft' OR state='submitted' OR state='paused')"
          % requestID)

  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error updating justIN database ' + str(e))

  return httpOK(startResponse, '')

def pauseRequestCmd(startResponse, jsonDict):

  try:
    requestID = int(jsonDict['request_id'])
  except:
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'Request ID must be given')

# change to handle errors properly eg no such request
  try:
    justin.db.insertUpdate("UPDATE requests SET state='paused' "
                        "WHERE request_id=%d "
                        "AND state='running'" % requestID)

  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error updating justIN database ' + str(e))

  return httpOK(startResponse, '')

def finishRequestCmd(startResponse, jsonDict):

  try:
    requestID = int(jsonDict['request_id'])
  except:
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'Request ID must be given')

# change to handle errors properly eg no such request
  try:
    justin.db.insertUpdate("UPDATE requests SET state='finished' "
                        "WHERE request_id=%d "
                        "AND state<>'deleted'" % requestID)

  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error updating justIN database ' + str(e))

  return httpOK(startResponse, '')

def createStageCmd(startResponse, jsonDict):

  try:
    requestID = int(jsonDict['request_id'])
  except:
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'Request ID must be given')
  try:
    stageID = int(jsonDict['stage_id'])
  except:
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'Stage ID must be given')

  try:
    processors = int(jsonDict['processors'])
  except:
    processors = 1

  try:
    wallSeconds = int(jsonDict['wall_seconds'])
  except:
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'Wall seconds must be given')

  try:
    rssBytes = int(jsonDict['rss_mb']) * 1024 * 1024
  except:
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'RSS MB must be given')

  if 'max_distance' in jsonDict and jsonDict['max_distance']:
    try:
      maxDistance = float(jsonDict['max_distance'])
    except:
      return httpError(startResponse, 
                       '400 Bad Request', 
                       '--max-distance option requires a numeric distance')
  else:
    maxDistance = 0.0

  if 'max_files_per_job' in jsonDict and jsonDict['max_files_per_job']:
    try:
      maxFilesPerJob = int(jsonDict['max_files_per_job'])
    except:
      return httpError(startResponse, 
                       '400 Bad Request', 
                       '--max-files-per-job option requires an integer')
  else:
    maxFilesPerJob = 1

  jobscriptID = 0

  try:
    jobscript = jsonDict['jobscript']
  except:
    jobscript = None

  if not jobscript:
    try:
      jsid = jsonDict['jobscript_id']
    except:
      jsid = None

    if not jsid:
      return httpError(startResponse, '400 Bad Request',
                       '--jobscript or --jobscript-id must by given')
    
    response = justin.lookupJobscript(jsid)
    if response['error']:
      return httpError(startResponse, '400 Bad Request', response['error'])

    jobscript   = response['jobscript']
    jobscriptID = response['jobscript_id']

  if 'scope' in jsonDict and jsonDict['scope']:
    # --scope option given, so check the scope is known
    scopeName = jsonDict['scope'].lower()

    if not justin.db.stringIsDomain(scopeName):
      return httpError(startResponse,
                       '400 Bad Request', 
                       'Scope name can only be characters a-z 0-9 - _ .')

    try:
      scopeRow = justin.db.select('SELECT scope_id FROM scopes '
                                  'WHERE scope_name="%s"' % scopeName, 
                                  justOne=True)
      scopeID = int(scopeRow['scope_id'])
    except:
      return httpError(startResponse,
                       '400 Bad Request', 
                       'Failed to find scope %s in justIN database' % scope)
  else:
    scopeName = None
    scopeID   = 0

  try:
    justin.db.insertUpdate("INSERT INTO stages SET "
                        "stage_rank=0,"
                        "request_id=%d,"
                        "stage_id=%d,"
                        "scope_id=%d,"
                        "jobscript_id=%d,"
                        "processors=%d,"
                        "wall_seconds=%d,"
                        "rss_bytes=%d,"
                        "max_distance=%f," 
                        "max_files_per_job=%d"
                        % (requestID, stageID, scopeID,
                           jobscriptID, processors,
                           wallSeconds, rssBytes, maxDistance,
                           maxFilesPerJob))
          
    justin.db.insertUpdate('INSERT INTO stages_jobscripts SET '
                           'request_id=%d,'
                           'stage_id=%d,'
                           'jobscript="%s"' 
                           % (requestID, stageID, 
                         jobscript.replace('\\','\\\\').replace('"','\\"')))

  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error updating justIN database ' + str(e))

  try:
    lifetimeDays = int(jsonDict['lifetime_days'])
  except:
    lifetimeDays = 1

  if (jsonDict['output_pattern'] or jsonDict['output_pattern_next_stage']) \
     and not scopeName:
    return httpError(startResponse, 
                     '400 Bad Request', 
                     '--scope must by given too for --output_pattern and '
                     '--output_pattern_next_stage')

  if jsonDict['output_pattern']:
    for i in jsonDict['output_pattern']:
    
      splitList = i.split(':')
       
      if len(splitList) < 2:
        continue
    
      datasetName = splitList[0]
      pattern     = ':'.join(splitList[1:])
        
      try:
        justin.db.insertUpdate('INSERT INTO stages_outputs SET '
              'request_id=%d,'
              'stage_id=%d,'
              'dataset="%s:%s",'
              'file_pattern="%s",'
              'lifetime_seconds=%d,'
              'for_next_stage=FALSE' % 
              (requestID, stageID,
               scopeName, datasetName.replace('\\','\\\\').replace('"','\\"'),
               pattern.replace('\\','\\\\').replace('"','\\"'),
               lifetimeDays * 86400
              )
             )

      except Exception as e:
        return httpError(startResponse, 
                         '500 Internal Server Error', 
                         'Error updating justIN database ' + str(e))

  if jsonDict['output_pattern_next_stage']:
    for i in jsonDict['output_pattern_next_stage']:
    
      splitList = i.split(':')
       
      if len(splitList) < 2:
        continue
    
      datasetName  = splitList[0]
      pattern      = ':'.join(splitList[1:])

      try:        
        justin.db.insertUpdate('INSERT INTO stages_outputs SET '
              'request_id=%d,'
              'stage_id=%d,'
              'dataset="%s:%s",'
              'file_pattern="%s',
              'lifetime_seconds=%d,'
              'for_next_stage=TRUE' % 
              (requestID, stageID,
               scopeName, datasetName.replace('\\','\\\\').replace('"','\\"'),
               pattern.replace('\\','\\\\').replace('"','\\"'),
               lifetimeDays * 86400
              )
             )

      except Exception as e:
        return httpError(startResponse, 
                         '500 Internal Server Error', 
                         'Error updating justIN database ' + str(e))
          
  if jsonDict['output_rse']:
    for rseName in jsonDict['output_rse']:
    
      if not justin.db.stringIsSite(rseName):
        return httpError(startResponse, 
                         '400 Bad Request', 
                         'Invalid RSE name')

      try:        
        justin.db.insertUpdate('INSERT INTO stages_output_storages SET '
              'request_id=%d,'
              'stage_id=%d,'
              'rse_id=(SELECT rse_id FROM storages WHERE rse_name="%s")' % 
              (requestID, stageID, rseName))

      except Exception as e:
        return httpError(startResponse, 
                         '500 Internal Server Error', 
                         'Error updating justIN database ' + str(e))

  if jsonDict['env']:
    for envNameValue in jsonDict['env']:    
      try:        
        (envName,envValue) = envNameValue.split('=',1)
      except:
        return httpError(startResponse,
                         '400 Bad Request',
                         'Failed to parse --env option')

      if not justin.db.stringIsEnvName(envName):
        return httpError(startResponse, 
                         '400 Bad Request', 
                         'Invalid environment variable name')

      try:
        justin.db.insertUpdate('INSERT IGNORE INTO stages_environment SET '
              'request_id=%d,'
              'stage_id=%d,'
              'env_name="%s",'
              'env_value="%s"' % 
              (requestID, 
               stageID, 
               envName, 
               envValue.replace('\\','\\\\').replace('"','\\"')
              ))

      except Exception as e:
        return httpError(startResponse, 
                         '500 Internal Server Error', 
                         'Error updating justIN database ' + str(e))

  return httpOK(startResponse, '')

def createJobscriptCmd(startResponse, jsonDict, userID, username):
  # Add a named jobscript to the jobscripts library NOT to a stage

  if 'jobscript' in jsonDict and jsonDict['jobscript']:
    jobscript = jsonDict['jobscript']
  else:
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'Uploaded jobscript is required')

  if 'name' in jsonDict and jsonDict['name']:
    name = jsonDict['name'].lower()
  else:
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'You must give a name for the jobscript')

  if not justin.db.stringIsDomain(name):
    return httpError(startResponse,
                     '400 Bad Request', 
                     'Jobscript name can only be characters a-z 0-9 - _ .')

  if 'description' in jsonDict and jsonDict['description']:
    description = jsonDict['description']
  else:
    description = ''

  if 'scope' in jsonDict and jsonDict['scope']:
    # --scope option given, so find the scope
    scopeName = jsonDict['scope'].lower()

    if not justin.db.stringIsDomain(scopeName):
      return httpError(startResponse,
                       '400 Bad Request', 
                       'Scope name can only be characters a-z 0-9 - _ .')

    try:
      scopeRow = justin.db.select('SELECT scope_id FROM scopes '
                                  'WHERE scope_name="%s"' % scopeName,
                                  justOne=True)
      scopeID = int(scopeRow['scope_id'])
    except:
      return httpError(startResponse,
                       '400 Bad Request', 
                       'Failed to find scope %s in justIN database' % scopeName) 

    jobscriptIdentifier = scopeName + ':' + name
    jobscriptUserID = 0
  else:
    # No scope, so set user_id instead
    scopeID = 0
    jobscriptUserID = userID
    jobscriptIdentifier = username + ':' + name

  try:
    # Check if jobscript with this user/scope and name exists already
    row = justin.db.select('SELECT jobscript_id FROM jobscripts_library '
                           'WHERE user_id=%d AND scope_id=%d AND '
                           'jobscript_name="%s"'
                           % (jobscriptUserID, scopeID, name), justOne = True)

    jobscriptID = int(row['jobscript_id'])

  except Exception as e:
    print(str(e), file=sys.stderr)
    # If not present, create one from scratch
    try:
      justin.db.insertUpdate('INSERT INTO jobscripts_library SET '
                             'scope_id=%d,'
                             'user_id=%d,'
                             'author_id=%d,'
                             'jobscript_name="%s",'
                             'jobscript="%s",'
                             'description="%s",'
                             'created_time=NOW()'
                       % (scopeID,
                          jobscriptUserID,
                          userID,
                          name,
                          jobscript.replace('\\','\\\\').replace('"','\\"'),
                          description.replace('\\','\\\\').replace('"','\\"')
                         ))

    except Exception as e:
      return httpError(startResponse, 
                       '500 Internal Server Error', 
                       'Error adding jobscript to library: ' + str(e))   
  else:
    # Already there, so update it with the new values
    try:
      justin.db.insertUpdate('UPDATE jobscripts_library SET '
                             'jobscript="%s",'
                             'author_id=%d,'
                             'description="%s",'
                             'created_time=NOW() '
                             'WHERE jobscript_id=%d '
                       % (jobscript.replace('\\','\\\\').replace('"','\\"'),
                          userID,
                          description.replace('\\','\\\\').replace('"','\\"'),
                          jobscriptID))

    except Exception as e:
      return httpError(startResponse, 
                       '500 Internal Server Error', 
                       'Error updating jobscript in library: ' + str(e))

  return httpOK(startResponse, jobscriptIdentifier + '\n')

def failFilesCmd(startResponse, jsonDict):

  try:
    requestID = int(jsonDict['request_id'])
  except:
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'Request ID must be given')

  try:
    stageID  = int(jsonDict['stage_id'])
    stageStr = 'AND stage_id=%d' % stageID
  except:
    stageStr = ''

  try:
    justin.db.insertUpdate('UPDATE files SET state="failed" '
          'WHERE request_id=%d %s '
          'AND state IN ("finding", "unallocated", "allocated", "outputting")'
          % (requestID, stageStr))

  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error updating justIN database ' + str(e))

  return httpOK(startResponse, '')

def showJobsCmd(startResponse, jsonDict):

  try:
    jobsubID = jsonDict['jobsub_id']
  except:
    jobsubID = None
  
  try:
    requestID = int(jsonDict['request_id'])
  except:
    requestID = None
  
  try:
    stageID = int(jsonDict['stage_id'])
  except:
    stageID = 1
  
  if jobsubID:
    filter = "WHERE jobsub_id='%s'" % jobsubID 
  elif requestID:
    filter = "WHERE request_id=%d AND stage_id=%d" % (requestID, stageID)
  else:
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'Either Jobsub ID or Request ID must be given')

  if jsonDict['state']:
    try:  
      filter += (' AND allocation_state="' +
                 re.sub('[^a-z]+', '', str(jsonDict['state'])) +
                 '"'
                )
    except:
      pass

  try:
    rows = justin.db.select("SELECT jobsub_id,request_id,stage_id,"
                         "allocation_state,allocation_time "
                         "FROM jobs "
                         + filter +
                         " ORDER BY justin_job_id")
  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error reading justIN database ' + str(e))

  outputString = ''
  for row in rows:
    outputString += ("%30s %5s %2s %10s  %s\n" % 
                     (row['jobsub_id'], row['request_id'], row['stage_id'], 
                      row['allocation_state'], row['allocation_time']))
   
  return httpOK(startResponse, outputString)

def getUser(environ):

  # Use certificates and proxies for now; will transition to tokens in future
  if 'SSL_CLIENT_S_DN' not in environ or not environ['SSL_CLIENT_S_DN']:
    return { 'error': 'Forbidden - identity not provided' }

  # Convert to the older format with slashes 
  clientDN='/'+'/'.join(environ['SSL_CLIENT_S_DN'].split(',')[::-1])

  try:
    row = justin.db.select('SELECT x509.user_id,username FROM x509 '
                         'LEFT JOIN users ON users.user_id=x509.user_id '
                         'WHERE x509dn=LEFT("%s",LENGTH(x509dn))' % 
                         clientDN.replace('\\','\\\\').replace('"','\\"'),
                         justOne = True)
  
    userID   = int(row['user_id'])
    username = row['username']
  except:
    return { 'error': 'Forbidden - acceptable identity not provided' }

  return { 'user_id': userID, 'username': username, 'error': None }

#
# Entry point from mod_wsgi
#
def application(environ, startResponse):

  justin.db.wsgiCallsCount += 1
  print('Call count (pid=%d): %d' % (os.getpid(), justin.db.wsgiCallsCount), 
        file=sys.stderr)

  # Quickly reject random GETs etc (if not hanlded by Apache already)
  if environ['REQUEST_METHOD'] != 'POST':
    return httpError(startResponse, 
                     '405 Method not allowed', 
                     'We only support POST')

  try:
    # True should provoke a reconnection attempt.
    # See https://github.com/farcepest/MySQLdb1/blob/master/_mysql.c#L1978
    # (Not sure if there is a more authoritative source for this API.)
    justin.db.conn.ping(True)
  except Exception as e:
    return httpError(startResponse,
                     '500 Internal Server Error',
                     'DB connection lost and cannot reconnect: ' + str(e))

  # Avoid leftovers from partial, failed transactions in this instance
  justin.db.conn.rollback()

  # This returns an error if an authorized DN is not found
  userDict = getUser(environ)

  if userDict['error']:
    return httpError(startResponse, 
                     '403 Forbidden', 
                     response['error'])

  try:
    inputLength = int(environ.get('CONTENT_LENGTH', '0'))
    inputString = environ['wsgi.input'].read(inputLength)
    jsonDict = json.loads(inputString)
  except Exception as e:
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'Failed to read and parse JSON')

  # Check jsonDict specifies a method
  if 'command' not in jsonDict:
    return httpError(startResponse,
                     '400 Bad Request', 
                     'Missing command in JSON')

  if jsonDict['command'] == 'time':
    return timeCmd(startResponse)

  if jsonDict['command'] == 'show-requests':
    return showRequestsCmd(startResponse, jsonDict)

  if jsonDict['command'] == 'show-stages':
    return showStagesCmd(startResponse, jsonDict)

  if jsonDict['command'] == 'show-jobscript':
    return showJobscriptCmd(startResponse, jsonDict)

  if jsonDict['command'] == 'show-stage-outputs':
    return showStageOutputsCmd(startResponse, jsonDict)

  if jsonDict['command'] == 'show-files':
    return showFilesCmd(startResponse, jsonDict)

  if jsonDict['command'] == 'fail-files':
    return failFilesCmd(startResponse, jsonDict)

  if jsonDict['command'] == 'show-replicas':
    return showReplicasCmd(startResponse, jsonDict)

  if jsonDict['command'] == 'show-storages':
    return showStoragesCmd(startResponse, jsonDict)

  if jsonDict['command'] == 'show-sites-storages':
    return showSitesStoragesCmd(startResponse, jsonDict)

  if jsonDict['command'] == 'create-request':
    return createRequestCmd(startResponse, jsonDict, userDict['user_id'])

  if jsonDict['command'] == 'quick-request':
    return quickRequestCmd(startResponse, jsonDict, userDict['user_id'])

  if jsonDict['command'] == 'submit-request':
    return submitRequestCmd(startResponse, jsonDict)

  if jsonDict['command'] == 'start-request':
    return startRequestCmd(startResponse, jsonDict)

  if jsonDict['command'] == 'pause-request':
    return pauseRequestCmd(startResponse, jsonDict)

  if jsonDict['command'] == 'finish-request':
    return finishRequestCmd(startResponse, jsonDict)

  if jsonDict['command'] == 'create-stage':
    return createStageCmd(startResponse, jsonDict)

  if jsonDict['command'] == 'create-jobscript':
    return createJobscriptCmd(startResponse, jsonDict, 
                              userDict['user_id'], userDict['username'])

  if jsonDict['command'] == 'show-jobs':
    return showJobsCmd(startResponse, jsonDict)

  return httpError(startResponse,
                   '400 Bad Request', 
                   'command in JSON not recognised')
