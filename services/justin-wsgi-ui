#
# justin-wsgi-ui - justIN commands and info API service
#
# Copyright 2013-23, Andrew McNab for the University of Manchester
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# This WSGI script relies on justin-api-import-script being run by
# the mod_wsgi directive WSGIImportScript

import os
import re
import sys
import time
import json
import string
import socket
import secrets
import datetime
import urllib.request
import rucio.client

import justin

def httpError(startResponse, code, message):

  justin.conn.rollback()
  print('justin-wsgi-commands fails with %s (%s)' % 
        (code, str(message)), file=sys.stderr)

  startResponse(code,
                [('Content-type',   'text/plain'),
                 ('Content-length', str(len(message)))
                ])

  return [(message + '\n').encode('UTF-8')]
  
def httpOK(startResponse, message):

  justin.conn.commit()
  startResponse('200 OK',
                [('Content-type',   'text/plain'),
                 ('Content-length', str(len(message)))
                ])

  return [message.encode('UTF-8')]
 
def timeCmd(startResponse):

  return httpOK(startResponse, 
                datetime.datetime.today().strftime('%Y-%m-%d %H:%M:%S UTC\n'))

def whoamiCmd(startResponse, user):

  outputString = \
'''      User name : %s
Session expires : %s UTC
         Groups : %s
''' % (user['user_name'], user['expires_time'], '  '.join(user['wlcg_groups']))

  return httpOK(startResponse, outputString)

def showWorkflowsCmd(startResponse, jsonDict):

  try:
    workflowID = int(jsonDict['workflow_id'])
  except:
    workflowID    = None
    workflowFilter = ""
  else:
    workflowFilter = "WHERE workflow_id=" + str(workflowID)

  try:
    rows = justin.select("SELECT * FROM workflows %s ORDER BY created" 
                         % workflowFilter)
  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error reading justIN database ' + str(e))

  outputString = ''
  for row in rows:
    outputString += ("%5d %-9s %s %s %s\n" % 
                     (row['workflow_id'], row['state'],
                      row['created'], row['description'], row['mql']))

  return httpOK(startResponse, outputString)

def showStagesCmd(startResponse, jsonDict):

  try:
    workflowID = int(jsonDict['workflow_id'])
  except:
    return httpError(startResponse, '400 Bad Request', 'Workflow ID not given')

  try:
    stageID = int(jsonDict['stage_id'])
  except:
    stageID    = None
    stageFilter = ""
  else:
    stageFilter = "AND stage_id=" + str(stageID)

  try:
    rows = justin.select("SELECT * FROM stages WHERE workflow_id=%d %s "
                         "ORDER BY workflow_id,stage_id" 
                         % (workflowID, stageFilter))
  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error reading justIN database ' + str(e))

  outputString = ''
  for row in rows:
    outputString += ("%5d %2d %d %d %d %.1f\n" % 
                     (row['workflow_id'], 
                      row['stage_id'], 
                      row['processors'],
                      row['wall_seconds'],
                      row['rss_bytes'],
                      row['max_distance'],
                    ))

  return httpOK(startResponse, outputString)

def showJobscriptCmd(startResponse, jsonDict):

  try:
    jsid = jsonDict['jobscript_id'].lower()
  except:
    jsid = None

  try:
    workflowID = int(jsonDict['workflow_id'])
  except:
    workflowID = 0

  try:
    stageID = int(jsonDict['stage_id'])
  except:
    stageID = 0

  if (jsid and (workflowID or stageID)) or \
     (not jsid and (not workflowID or not stageID)):
    return httpError(startResponse,
                     '400 Bad Request', 
          '--jobscript-id OR --workflow-id/--stage-id must be given')

  if jsid:
    # From Jobscripts Library with JSID
    response = justin.lookupJobscript(jsid)
    
    if response['error']:
      return httpError(startResponse,
                       '400 Bad Request', 
                       response['error'])
      
    jobscript = response['jobscript']

  else:
    # From stage with workflowID and stageID
    query = ('SELECT jobscript FROM stages_jobscripts '
             'WHERE workflow_id=%d AND stage_id=%d'
             % (workflowID, stageID))
  
    try:
      row = justin.select(query, justOne = True)
      jobscript = row['jobscript']
    except Exception as e:
      return httpError(startResponse, 
                      '500 Internal Server Error', 
                      'Error reading justIN database ' + str(e))

  if not jobscript.endswith('\n'):
    jobscript += '\n'

  return httpOK(startResponse, jobscript)

def showStageOutputsCmd(startResponse, jsonDict):

  try:
    workflowID = int(jsonDict['workflow_id'])
  except:
    return httpError(startResponse, '400 Bad Request', 'Workflow ID not given')

  try:
    stageID = int(jsonDict['stage_id'])
  except:
    return httpError(startResponse, '400 Bad Request', 'Stage ID not given')

  try:
    rows = justin.select("SELECT for_next_stage,"
                            "scopes.scope_name,"
                            "file_pattern,"
                            "destination "
                            "FROM stages_outputs "
                            "LEFT JOIN workflows "
                            "ON workflows.workflow_id=stages_outputs.workflow_id "
                            "LEFT JOIN scopes "
                            "ON workflows.scope_id=scopes.scope_id "
                            "WHERE stages_outputs.workflow_id=%d "
                            "AND stages_outputs.stage_id=%d "
                            "ORDER BY destination,file_scope,file_pattern" 
                            % (workflowID, stageID))
  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error reading justIN database ' + str(e))

  outputString = ''
  for row in rows:
    nextStage = '(next)' if row['for_next_stage'] else '(    )'

    outputString += ("%s %s %s %s\n" % (nextStage,
                                        row['scope_name'],
                                        row['file_pattern'],
                                        row['destination']))
   
  return httpOK(startResponse, outputString)

def queryMetaCat(mql):

  try:
    response = urllib.request.urlopen(
              "https://metacat.fnal.gov:9443/dune_meta_prod/app/data/query?"
              "with_meta=no&with_provenance=no",
              data = mql.encode() )

    if response.status != 200:
      print("Reading files list from MetaCat for %s fails with HTTP code %d"
            % (mql, response.status), file=sys.stderr)
      return None

    fileLines = response.readlines()
  except Exception as e:    
    print("Reading files list from MetaCat for %s fails with: %s" 
          % (mql, str(e)), 
          file=sys.stderr)
    return None

  fileDIDs = []

  for fileLine in fileLines:
    if fileLine[0] < 32:
      fileLine = fileLine[1:]

    try:
      fileDict = json.loads(fileLine)
    except Exception as e:
      print('JSON parse of %s fails: %s' % (str(fileLine), str(e)))
      return None
    else:
      fileDIDs.append({'scope' : fileDict['namespace'], 
                       'name'  : fileDict['name']       })

  return fileDIDs

def queryRucio(fileDIDs):

  # Check we can talk to Rucio
  try:
    repClient = \
     rucio.client.replicaclient.ReplicaClient(rucio_host = 'https://dune-rucio.fnal.gov',
                        auth_host = 'https://auth-dune-rucio.fnal.gov',
                        ca_cert   = '/etc/grid-security/certificates',
                        auth_type = 'x509', 
                        account   = 'dunepro',
#                        creds     = {'client_cert': '/var/lib/justin/dunepro.proxy.pem'})
##### NEEDS CHANGING ONCE justin-jobs-production IS IN RUCIO FOR dunepro
                        creds     = {'client_cert': '/var/lib/justin/justin-jobs-production.proxy.pem'})
  except Exception as e:
    print("Connect to Rucio fails with: " + str(e), file=sys.stderr)
    return None
  
  # Use the Rucio API to get a big list of replicas for the files
  try:
    wanRepsList = repClient.list_replicas(fileDIDs,
                                          schemes=['root'], 
                                          domain='wan')

  except Exception as e:
    print("Reading RSE replicas info fails with: " + str(e), file=sys.stderr)
    return None

  output = ''
  for rep in list(wanRepsList):
    for rse in rep['rses']:
      output += '%s:%s %s %s\n' % (rep['scope'],
                                 rep['name'],
                                 rep['rses'][rse][0],
                                 rse)

  return output

def showFilesCmd(startResponse, jsonDict):

  try:
    mql = jsonDict['mql']  
  except:
    mql = None
  
  try:
    workflowID = int(jsonDict['workflow_id'])
  except:
    workflowID = None

  if (mql and workflowID) or (not mql and not workflowID):
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'Workflow ID or MQL must be given (but not both)')

  if mql:
    fileDIDs = queryMetaCat(mql)
    if fileDIDs is None:
      return httpError(startResponse, 
                       '400 Bad Request', 
                       'MQL query error')

    outputString = ''
    for oneDID in fileDIDs[:100]:
      outputString += '%s:%s\n' % (oneDID['scope'], oneDID['name'])
    return httpOK(startResponse, outputString)
  
  filter = ''

  try:
    filter += 'AND files.stage_id=%d ' % int(jsonDict['stage_id'])
  except: 
    pass

  try:
    fileDID = jsonDict['file_did']

    if not justin.stringIsDID(fileDID):
      raise

    filter += 'AND files.file_did="%s" ' % fileDID
  except:
    pass

  try:
    rows = justin.select("SELECT * FROM files "
                            "WHERE workflow_id=%d %s "
                            "AND files.stage_id > 0 "
                            "ORDER BY workflow_id,stage_id,file_did"
                            % (workflowID, filter))
  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error reading justIN database ' + str(e))

  outputString = ''
  for row in rows:
    outputString += ("%d %d %s %s\n" % 
                     (row['workflow_id'],
                      row['stage_id'],
                      row['state'],
                      row['file_did'],
                     )
                    )
   
  return httpOK(startResponse, outputString)

def showReplicasCmd(startResponse, jsonDict):

  try:
    mql = jsonDict['mql']  
  except:
    mql = None
  
  try:
    workflowID = int(jsonDict['workflow_id'])
  except:
    workflowID = None

  if (mql and workflowID) or (not mql and not workflowID):
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'Workflow ID or MQL must be given (but not both)')

  if mql and mql.strip().startswith('monte-carlo '):
    try:
      count = int(mql.strip().split()[1])
    except:
      return httpError(startResponse, 
                       '400 Bad Request', 
                       'Must give integer count with MQL monte-carlo query')

    outputString = ''

    for i in range(1, min(count + 1, 101)):
      outputString += 'monte-carlo-%06d-%06d %06d MONTECARLO\n' % (1, i, i)

    return httpOK(startResponse, outputString)

  if mql:
    fileDIDs = queryMetaCat(mql)
    if fileDIDs is None:
      return httpError(startResponse, 
                       '400 Bad Request', 
                       'MQL query error')

    outputString = queryRucio(fileDIDs)

    if outputString is None:
      return httpError(startResponse, 
                       '400 Bad Request', 
                       'Rucio query error')

    return httpOK(startResponse, outputString)

  filter = ''

  try:
    filter += 'AND files.stage_id=%d ' % int(jsonDict['stage_id'])
  except: 
    pass

  try:
    fileDID = jsonDict['file_did']

    if not justin.stringIsDID(fileDID):
      raise

    filter += 'AND files.file_did="%s" ' % fileDID
  except:
    pass

  try:
    rseName = jsonDict['rse_name']

    if not justin.stringIsSite(rseName):
      raise

    filter += 'AND storages.rse_name="%s" ' % rseName
  except:
    pass

  try:
    rows = justin.select("SELECT replicas.workflow_id,replicas.stage_id,"
                 "files.state,"
                 "storages.rse_name,files.file_did,replicas.wan_pfn "
                 "FROM replicas "
                 "LEFT JOIN storages ON replicas.rse_id=storages.rse_id "
                 "LEFT JOIN files ON replicas.file_id=files.file_id "
                 "WHERE workflow_id=%d %s AND replicas.stage_id > 0 ORDER BY "
                 "files.workflow_id,files.stage_id,files.file_did LIMIT 100"
                 % (workflowID, filter))
  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error reading justIN database ' + str(e))

  outputString = ''
  for row in rows:
    outputString += ("%5d %2d %-11s %s %s %s\n" %
                     (row['workflow_id'],
                      row['stage_id'],
                      row['state'],
                      row['file_did'],
                      row['rse_name'],
                      row['wan_pfn']
                     )
                    )
   
  return httpOK(startResponse, outputString)

def createWorkflow(jsonDict, user, simple = False):

  if 'description' in jsonDict and jsonDict['description']:
    description = jsonDict['description']
  else:
    description = ''

  if 'mql' in jsonDict and jsonDict['mql']:
    mql = jsonDict['mql']
  else:
    mql = ''

  if 'monte_carlo' in jsonDict and jsonDict['monte_carlo']:
    try:
      mql = 'monte-carlo %d' % int(jsonDict['monte_carlo'])
    except:
      return ('400 Bad Request',
              'Monte Carlo option requires an integer count')

  if 'scope' in jsonDict and jsonDict['scope']:
    # --scope option given, so check the scope is known
    scopeName = jsonDict['scope'].lower()

    if not justin.stringIsDomain(scopeName):
      return ('400 Bad Request', 
              'Scope name can only be characters a-z 0-9 - _ .')

    try:
      scopeRow = justin.select('SELECT scope_id,wlcg_group_name '
                          'FROM scopes '
                          'LEFT JOIN wlcg_groups '
                          'ON wlcg_groups.wlcg_group_id=scopes.wlcg_group_id '
                          'WHERE scope_name="%s"' % scopeName, 
                          justOne=True)

      wlcgGroupName = scopeRow['wlcg_group_name']
      scopeID       = int(scopeRow['scope_id'])
      if not scopeID:
        raise
    except:
      return ('400 Bad Request', 
              'Failed to find scope %s in justIN database' % scope)
 
    if not wlcgGroupName:
      return ('403 Forbidden', 
              'Scope %s has no group defined and cannot yet be used via justIN'  
              % scopeName)

    if wlcgGroupName not in user['wlcg_groups']:
      return ('403 Forbidden', 
              'You need to be in group %s to use scope %s' % (wlcgGroupName, scopeName))
  else:
    scopeName = None
    scopeID   = 0

  refindEnd     = justin.unixEpoch
  refindSeconds = 0

  # Record refind interval if given explicitly
  if 'refind_interval_hours' in jsonDict and jsonDict['refind_interval_hours']:
    try:
      refindSeconds = int(jsonDict['refind_interval_hours']) * 3600
    except:
      return httpError(startResponse, 
                       '400 Bad Request',
                       '--refind-interval-hours requires an integer argument')

  # Record end time if end date is given explicitly
  if 'refind_end_date' in jsonDict and jsonDict['refind_end_date']:
    try:
      yyyymmdd = str(int(jsonDict['refind_end_date']))
      refindEnd = '%s-%s-%s 23:59:59' % (yyyymmdd[0:4],
                                         yyyymmdd[4:6], 
                                         yyyymmdd[6:8])
    except:
      return httpError(startResponse, 
                       '400 Bad Request', 
                       '--refind-end-date requires a YYYYMMDD date')

  # If one of the refind options is given but not the other, use the default

  if refindEnd == justin.unixEpoch and refindSeconds > 0:
    # end time is still unset but we did give --refind-interval-hours
    refindEnd = datetime.datetime.today().strftime('%Y-%m-%d 23:59:59')
  elif refindSeconds == 0 and refindEnd != justin.unixEpoch: 
    # interval seconds is still unset, but we did give an end time
    refindSeconds = 3600

  try:
    workflowID = justin.insertUpdate('INSERT INTO workflows SET created=NOW(),'
          'state="%s",'
          '%s'
          'description="%s",'
          'mql="%s",'
          'scope_id=%d,'
          'user_id=%d,'
          'refind_seconds=%d,'
          'refind_end_time="%s" '
          % ('submitted' if simple else 'draft',
             'submitted=NOW(),' if simple else '',
             description,
             mql,
             scopeID,
             user['user_id'],
             refindSeconds,
             refindEnd))
  except Exception as e:
    return ('500 Internal Server Error', 
            'Error creating workflow: ' + str(e))

  return ('200 OK', workflowID)

def createWorkflowCmd(startResponse, jsonDict, user):

  (code, message) = createWorkflow(jsonDict, user)

  if code == '200 OK':
    return httpOK(startResponse, str(message) + '\n')

  return httpError(startResponse, code, message)

def simpleWorkflowCmd(startResponse, jsonDict, user):

  if 'monte_carlo' in jsonDict and jsonDict['monte_carlo']:
    jsonDict['max_distance'] = 100

  # First create the workflow
  (code, workflowMessage) = createWorkflow(jsonDict, user, simple = True)

  if code != '200 OK':
    return httpError(startResponse, code, workflowMessage)

  # Then create its single stage
  jsonDict['workflow_id'] = int(workflowMessage)
  jsonDict['stage_id']   = 1
  (code, stageMessage) = createStage(jsonDict, user, simple = True, 
                                     scopeName = jsonDict['scope'])

  if code != '200 OK':
    return httpError(startResponse, code, stageMessage)

  # We output the message from the workflow creation
  return httpOK(startResponse, str(workflowMessage) + '\n')

def modifyWorkflowCmds(startResponse, jsonDict, user):
  # Generic handler for restart-workflow, submit-workflow, pause-workflow and
  # finish-workflow

  try:
    workflowID = int(jsonDict['workflow_id'])
  except:
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'Workflow ID must be given')

  try:
    row = justin.select('SELECT workflows.user_id,workflows.state,'
                        'wlcg_group_name FROM workflows '
                        'LEFT JOIN scopes '
                        'ON scopes.scope_id=workflows.scope_id '
                        'LEFT JOIN wlcg_groups '
                        'ON wlcg_groups.wlcg_group_id=scopes.wlcg_group_id '
                        'WHERE workflows.workflow_id=%d' % workflowID,
                        justOne = True)

    workflowUserID = int(row['user_id'])
    workflowState  = row['state']
    wlcgGroupName = row['wlcg_group_name']
  except Exception as e:
    return httpError(startResponse,
                     '500 Internal Server Error',
                     'Database error: ' + str(e))
  
  if workflowUserID != user['user_id'] and \
     wlcgGroupName not in user['wlcg_groups']:
    return httpError(startResponse,
                     '403 Forbidden',
                     'You do not have permission to update that workflow')
  
  if jsonDict['command'] == 'submit-workflow':
    if workflowState != 'draft':
      return httpError(startResponse,
                   '403 Forbidden',
                   'You cannot submit a workflow that was already submitted')

    # Submitting updates user_id to the person who actually submitted it
    query = ("UPDATE workflows SET "
             "state='submitted',submitted=NOW(),user_id=%d "
             "WHERE workflow_id=%d AND state='draft'" 
             % (workflowID, user['user_id']))

  elif jsonDict['command'] == 'restart-workflow':
    if workflowState != 'paused':
      return httpError(startResponse,
                       '403 Forbidden',
                       'You cannot restart a workflow that is not paused')

    query = ("UPDATE workflows SET state='running' "
             "WHERE workflow_id=%d AND state='paused'"
             % workflowID)

  elif jsonDict['command'] == 'pause-workflow':
    if workflowState != 'running':
      return httpError(startResponse,
                       '403 Forbidden',
                       'You cannot pause a workflow that is not running')

    query = ("UPDATE workflows SET state='paused' "
             "WHERE workflow_id=%d "
             "AND state='running'" % workflowID)

  elif jsonDict['command'] == 'finish-workflow':
    if workflowState != 'running' and workflowState != 'submitted':
      return httpError(startResponse,
                       '403 Forbidden',
                       'You cannot finish a workflow that is not running')

    query = ("UPDATE workflows SET state='finished',finished=NOW() "
             "WHERE workflow_id=%d "
             "AND (state='running' OR state='submitted')" % workflowID)

  try:
    justin.insertUpdate(query)
  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error updating workflow state: ' + str(e))

  return httpOK(startResponse, '')

def createStage(jsonDict, user, simple = False, scopeName = None):

  try:
    workflowID  = int(jsonDict['workflow_id'])
  except:
    return ('400 Bad Request', 'Workflow ID must be given')

  if not simple:
    # Check reference is to a valid existing workflow
    try:
      workflowRow = justin.select('SELECT workflows.scope_id,scope_name,'
                           'wlcg_group_name,workflows.user_id FROM workflows '
                           'LEFT JOIN scopes '
                           'ON scopes.scope_id=workflows.scope_id '
                           'LEFT JOIN wlcg_groups '
                           'ON wlcg_group.wlcg_group_id=scopes.wlcg_group_id '
                           'WHERE workflow_id=%d' % workflowID, 
                           justOne = True)
      workflowUserID = int(workflowRow['user_id'])
      scopeID       = int(workflowRow['scope_id'])
      scopeName     = workflowRow['scope_name']
      wlcgGroupName = workflowRow['wlcg_group_name']
    except:
      return ('400 Bad Request', 'Valid workflow ID must be given')

    if workflowUserID != user['user_id'] and \
       wlcgGroupName not in user['wlcg_groups']:
      return ('403 Forbidden', 
              'You do not have permission to add a stage to that workflow')

  try:
    stageID = int(jsonDict['stage_id'])
  except:
    return ('400 Bad Request', 'Stage ID must be given')

  try:
    processors = int(jsonDict['processors'])
  except:
    processors = 1

  try:
    wallSeconds = int(jsonDict['wall_seconds'])
  except:
    wallSeconds = 80000

  try:
    rssBytes = int(jsonDict['rss_mb']) * 1024 * 1024
  except:
    rssBytes = 2000 * 1024 * 1024

  if 'max_distance' in jsonDict and jsonDict['max_distance']:
    try:
      maxDistance = float(jsonDict['max_distance'])
    except:
      return ('400 Bad Request', '--max-distance option requires a numeric distance')
  else:
    maxDistance = 0.0

  jobscriptID = 0

  try:
    jobscript = jsonDict['jobscript']
  except:
    jobscript = None

  if not jobscript:
    try:
      jsid = jsonDict['jobscript_id']
    except:
      jsid = None

    if not jsid:
      return ('400 Bad Request', '--jobscript or --jobscript-id must by given')
    
    response = justin.lookupJobscript(jsid)
    if response['error']:
      return ('400 Bad Request', response['error'])

    jobscript   = response['jobscript']
    jobscriptID = response['jobscript_id']

  try:
    justin.insertUpdate("INSERT INTO stages SET "
                        "stage_priority=50,"
                        "workflow_id=%d,"
                        "stage_id=%d,"
                        "jobscript_id=%d,"
                        "processors=%d,"
                        "wall_seconds=%d,"
                        "rss_bytes=%d,"
                        "max_distance=%f" 
                        % (workflowID, stageID, 
                           jobscriptID, processors,
                           wallSeconds, rssBytes, maxDistance))
          
    justin.insertUpdate('INSERT INTO stages_jobscripts SET '
                           'workflow_id=%d,'
                           'stage_id=%d,'
                           'jobscript="%s"' 
                           % (workflowID, stageID, 
                         jobscript.replace('\\','\\\\').replace('"','\\"')))

  except Exception as e:
    return ('500 Internal Server Error', 
            'Error updating stages/stages_jobscripts in database ' + str(e))

  try:
    lifetimeDays = int(jsonDict['lifetime_days'])
  except:
    lifetimeDays = 1

  justinEnvVars = { 'JUSTIN_WORKFLOW_ID' : str(workflowID),
                    'JUSTIN_STAGE_ID'    : str(stageID)    }

  if scopeName:
    justinEnvVars['JUSTIN_SCOPE'] = scopeName

  outputPatterns = []

  # check output_pattern is not None then proceed
  if jsonDict['output_pattern']:
    for i in jsonDict['output_pattern']:
      try:
        (pattern, destination) = i.split(':', 1)
      except:
        return ('400 Bad Request',
                'Output patterns must be of the form PATTERN:DESTINATION')

      if not destination.startswith('https://') and not scopeName:
        return ('400 Bad Request', 
                'A scope must be specified when creating the workflow if '
                '--output-pattern is given for this stage '
                'and a Rucio dataset is given.')

      destination = justin.expandEnvVars(destination, justinEnvVars)
      outputPatterns.append((False, pattern, destination))

  if not simple:
    # check output_pattern is not None then proceed
    if jsonDict['output_pattern_next_stage']:
      for i in jsonDict['output_pattern_next_stage']:
        try:
          (pattern, destination) = i.split(':', 1)
        except:
          return ('400 Bad Request',
                  'Output patterns must be of the form PATTERN:DESTINATION')

        if not destination.startswith('https://') and not scopeName:
          return ('400 Bad Request', 
                  'A scope must be specified when creating the workflow if '
                  '--output-pattern-next-stage is given for this stage '
                  'and a Rucio dataset is given.')

        destination = justin.expandEnvVars(destination, justinEnvVars)
        outputPatterns.append((True, pattern, destination))

  for (forNextStage, pattern, destination) in outputPatterns:

    if not justin.stringIsFilePattern(pattern):
      return ('400 Bad Request', 'Invalid file pattern')

    if destination.startswith('https://'):
        # HTTPS upload URL
   
        if forNextStage:
          return ('400 Bad Request', 
                  'Output for next stage must be within a Rucio dataset')

        if not justin.stringIsURL(destination):
          return ('400 Bad Request', 'Invalid destination URL')

        if destination[-1] == '/':
          destination = destination[:-1]

        # Add Workflow ID and Stage ID to URL
        destination = destination + '/%05d/%d' % (workflowID, stageID)
    else:
        # Rucio dataset name
        if not justin.stringIsDID(destination) or ':' in destination:
          return ('400 Bad Request',
                  'Invalid Rucio dataset name: ' + str(destination))
    try:
        justin.insertUpdate('INSERT INTO stages_outputs SET '
              'workflow_id=%d,'
              'stage_id=%d,'
              'destination="%s",'
              'file_pattern="%s",'
              'lifetime_seconds=%d,'
              'for_next_stage=%s' % 
              (workflowID, stageID,
               destination,
               pattern,
               lifetimeDays * 86400,
               forNextStage
              )
             )

    except Exception as e:
        return ('500 Internal Server Error',
                'Error adding stage output: ' + str(e))

  if jsonDict['output_rse']:
    for rseName in jsonDict['output_rse']:
    
      if not justin.stringIsSite(rseName):
        return ('400 Bad Request', 'Invalid RSE name')

      try:        
        justin.insertUpdate('INSERT INTO stages_output_storages SET '
              'workflow_id=%d,'
              'stage_id=%d,'
              'rse_id=(SELECT rse_id FROM storages WHERE rse_name="%s")' % 
              (workflowID, stageID, rseName))

      except Exception as e:
        return ('500 Internal Server Error', 
                'Error adding output RSE: ' + str(e))

  if jsonDict['env']:
    for envNameValue in jsonDict['env']:    
      try:        
        (envName,envValue) = envNameValue.split('=',1)
      except:
        return ('400 Bad Request', 'Failed to parse --env option')

      envValue = justin.expandEnvVars(envValue, justinEnvVars)

      if not justin.stringIsEnvName(envName):
        return ('400 Bad Request', 'Invalid environment variable name')

      try:
        justin.insertUpdate('INSERT IGNORE INTO stages_environment SET '
              'workflow_id=%d,'
              'stage_id=%d,'
              'env_name="%s",'
              'env_value="%s"' % 
              (workflowID, 
               stageID, 
               envName, 
               envValue.replace('\\','\\\\').replace('"','\\"')
              ))

      except Exception as e:
        return ('500 Internal Server Error', 
                'Error adding environment variables: ' + str(e))

  if jsonDict['classad']:
    for classadNameValue in jsonDict['classad']:    
      try:        
        (classadName,classadValue) = classadNameValue.split('=',1)
      except:
        return ('400 Bad Request', 'Failed to parse --classad option')

      classadValue = justin.expandEnvVars(classadValue, justinEnvVars)

      if not justin.stringIsEnvName(classadName):
        return ('400 Bad Request', 'Invalid ClassAd name')

      try:
        justin.insertUpdate('INSERT IGNORE INTO stages_classads SET '
              'workflow_id=%d,'
              'stage_id=%d,'
              'classad_name="%s",'
              'classad_value="%s"' % 
              (workflowID, 
               stageID, 
               classadName, 
               classadValue.replace('\\','\\\\').replace('"','\\"')
              ))

      except Exception as e:
        return ('500 Internal Server Error', 
                'Error adding custom ClassAds: ' + str(e))

  return ('200 OK', '')

def createStageCmd(startResponse, jsonDict, user):

  (code, message) = createStage(jsonDict, user)

  if code == '200 OK':
    return httpOK(startResponse, message)

  return httpError(startResponse, code, message)

def createJobscriptCmd(startResponse, jsonDict, user):
  # Add a named jobscript to the jobscripts library NOT to a stage

  if 'jobscript' in jsonDict and jsonDict['jobscript']:
    jobscript = jsonDict['jobscript'] + '\n'
  else:
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'Uploaded jobscript is required')

  if 'name' in jsonDict and jsonDict['name']:
    name = jsonDict['name'].lower()
  else:
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'You must give a name for the jobscript')

  if not justin.stringIsDomain(name):
    return httpError(startResponse,
                     '400 Bad Request', 
                     'Jobscript name can only be characters a-z 0-9 - _ .')

  if 'description' in jsonDict and jsonDict['description']:
    description = jsonDict['description']
  else:
    description = ''

  if 'scope' in jsonDict and jsonDict['scope']:
    # --scope option given, so find the scope
    scopeName = jsonDict['scope'].lower()

    if not justin.stringIsDomain(scopeName):
      return httpError(startResponse,
                       '400 Bad Request', 
                       'Scope name can only be characters a-z 0-9 - _ .')

    try:
      scopeRow = justin.select('SELECT scope_id,wlcg_group_name '
                           'FROM scopes '
                           'LEFT JOIN wlcg_groups '
                           'ON wlcg_groups.wlcg_group_id=scopes.wlcg_group_id '
                           'WHERE scope_name="%s"' % scopeName,
                           justOne=True)
      scopeID       = int(scopeRow['scope_id'])
      wlcgGroupName = scopeRow['wlcg_group_name']
    except Exception as e:
      print('Finding scope fails: ' + str(e), file=sys.stderr)
      return httpError(startResponse,
                       '400 Bad Request', 
                       'Failed to find scope %s in justIN database' % scopeName) 

    if not wlcgGroupName:
      return httpError(startResponse,
                       '403 Forbidden',
                       'Scope %s has no group defined and cannot yet be '
                       'used via justIN' % scopeName)

    if wlcgGroupName not in user['wlcg_groups']:
      return httpError(startResponse,
                       '403 Forbidden', 
                       'You need to be in group %s to use scope %s' 
                       % (wlcgGroupName, scopeName))

    jobscriptIdentifier = scopeName + ':' + name
    jobscriptUserID = 0
  else:
    # No scope, so set user_id instead
    scopeID = 0
    jobscriptUserID = user['user_id']
    jobscriptIdentifier = user['user_name'] + ':' + name

  try:
    # Check if jobscript with this user/scope and name exists already
    row = justin.select('SELECT jobscript_id FROM jobscripts_library '
                           'WHERE user_id=%d AND scope_id=%d AND '
                           'jobscript_name="%s"'
                           % (jobscriptUserID, scopeID, name), justOne = True)

    jobscriptID = int(row['jobscript_id'])

  except Exception as e:
    print(str(e), file=sys.stderr)
    # If not present, create one from scratch
    try:
      justin.insertUpdate('INSERT INTO jobscripts_library SET '
                             'scope_id=%d,'
                             'user_id=%d,'
                             'author_id=%d,'
                             'jobscript_name="%s",'
                             'jobscript="%s",'
                             'description="%s",'
                             'created_time=NOW()'
                       % (scopeID,
                          jobscriptUserID,
                          user['user_id'],
                          name,
                          jobscript.replace('\\','\\\\').replace('"','\\"'),
                          description.replace('\\','\\\\').replace('"','\\"')
                         ))

    except Exception as e:
      return httpError(startResponse, 
                       '500 Internal Server Error', 
                       'Error adding jobscript to library: ' + str(e))   
  else:
    # Already there, so update it with the new values
    try:
      justin.insertUpdate('UPDATE jobscripts_library SET '
                             'jobscript="%s",'
                             'author_id=%d,'
                             'description="%s",'
                             'created_time=NOW() '
                             'WHERE jobscript_id=%d '
                       % (jobscript.replace('\\','\\\\').replace('"','\\"'),
                          user['user_id'],
                          description.replace('\\','\\\\').replace('"','\\"'),
                          jobscriptID))

    except Exception as e:
      return httpError(startResponse, 
                       '500 Internal Server Error', 
                       'Error updating jobscript in library: ' + str(e))

  return httpOK(startResponse, jobscriptIdentifier + '\n')

def failFilesCmd(startResponse, jsonDict, user):

  try:
    workflowID = int(jsonDict['workflow_id'])
  except:
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'Workflow ID must be given')

  try:
    row = justin.select('SELECT workflows.user_id,wlcg_group_name '
                        'FROM workflows '
                        'LEFT JOIN scopes '
                        'ON scopes.scope_id=workflows.scope_id '
                        'LEFT JOIN wlcg_groups '
                        'ON wlcg_groups.wlcg_group_id=scopes.wlcg_group_id '
                        'WHERE workflows.workflow_id=%d' % workflowID, 
                        justOne = True)

    workflowUserID = row['user_id']
    wlcgGroupName = row['wlcg_group_name']
  except:
    return httpError(startResponse,
                     '500 Internal Server Error',
                     'Database error')
  
  if workflowUserID != user['user_id'] and \
     wlcgGroupName not in user['wlcg_groups']:
    return httpError(startResponse,
                     '403 Forbidden',
                     'You do not have permission to update that workflow')

  try:
    stageID  = int(jsonDict['stage_id'])
    stageStr = 'AND stage_id=%d' % stageID
  except:
    stageStr = ''

  try:
    justin.insertUpdate('UPDATE files SET state="failed" '
          'WHERE workflow_id=%d %s '
          'AND state IN ("finding", "unallocated", "allocated", "outputting")'
          % (workflowID, stageStr))

  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error marking files as failed: ' + str(e))

  return httpOK(startResponse, '')

def showJobsCmd(startResponse, jsonDict):

  try:
    jobsubID = jsonDict['jobsub_id']
  except:
    jobsubID = None
  
  try:
    workflowID = int(jsonDict['workflow_id'])
  except:
    workflowID = None
  
  try:
    stageID = int(jsonDict['stage_id'])
  except:
    stageID = 1
  
  if jobsubID:
    filter = "WHERE jobsub_id='%s'" % jobsubID 
  elif workflowID:
    filter = "WHERE workflow_id=%d AND stage_id=%d" % (workflowID, stageID)
  else:
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'Either Jobsub ID or Workflow ID must be given')

  if jsonDict['state']:
    try:  
      filter += (' AND job_state="' +
                 re.sub('[^a-z]+', '', str(jsonDict['state'])) +
                 '"'
                )
    except:
      pass

  try:
    rows = justin.select("SELECT jobsub_id,workflow_id,stage_id,"
                         "job_state,allocation_time "
                         "FROM jobs "
                         + filter +
                         " ORDER BY justin_job_id")
  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error reading justIN database ' + str(e))

  outputString = ''
  for row in rows:
    outputString += ("%30s %5s %2s %10s  %s\n" % 
                     (row['jobsub_id'], row['workflow_id'], row['stage_id'], 
                      row['job_state'], row['allocation_time']))
   
  return httpOK(startResponse, outputString)

#
# Start of utility functions
#
def getUser(jsonDict):

  try:
    session = jsonDict['session']
    secret  = jsonDict['secret']

    if not session or not secret or \
       not justin.stringIsSite(session) or not justin.stringIsSite(secret):
      raise
  except:
    return None

  try:
    row = justin.select(
           'SELECT principal_name,sessions.user_id,'
           'sessions.wlcg_groups,expires_time '
           'FROM sessions '
           'LEFT JOIN users ON users.user_id=sessions.user_id '
           'LEFT JOIN principal_names '
           'ON principal_names.pn_id=users.main_pn_id '
           'WHERE justin_session="%s" AND justin_secret="%s" AND '
           'sessions.user_id<>0 AND sessions.expires_time > NOW() '
           'AND session_type="command"' % (session, secret),
           justOne = True)
  
    userID         = int(row['user_id'])
    userName       = row['principal_name']
    wlcgGroups     = row['wlcg_groups'].split()
    expiresTime    = row['expires_time']
  except Exception as e:
    print('Finding session fails with: ' + str(e), file=sys.stderr)
    return None

  return { 'user_id'         : userID,
           'user_name'       : userName,
           'expires_time'    : expiresTime,
           'wlcg_groups'     : wlcgGroups }

def newSession(startResponse, environ, jsonDict):
  
  justinSession = secrets.token_urlsafe(64)
  justinSecret  = secrets.token_urlsafe(64)
  justinCode    = secrets.token_urlsafe(25)
  savedURI      = '/dashboard/'
  userAgent     = environ.get('HTTP_USER_AGENT', '')
  ip            = environ.get('REMOTE_ADDR', '')
  hostname      = ''

  if ip:
    try:
      hostname = socket.gethostbyaddr(ip)[0]
    except:
      pass

  try:
    justin.insertUpdate('INSERT INTO sessions SET '
                        'session_type="command",'
                        'created_time=NOW(),'
                        'expires_time=DATE_ADD(NOW(),INTERVAL 10 MINUTE),'
                        'justin_session="%s",'
                        'justin_secret="%s",'
                        'justin_code="%s",'
                        'user_agent="%s",'
                        'saved_uri="%s",'
                        'ip="%s",'
                        'hostname="%s",'
                        'os_release="%s"'
                        % (justinSession, justinSecret, justinCode,
                           userAgent.replace('\\','\\\\').replace('"','\\"'),
                           savedURI,
                           ip, hostname,
              jsonDict['os_release'].replace('\\','\\\\').replace('"','\\"') ))
    justin.conn.commit()
  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Failed creating session: ' + str(e))

  outputDict = { 'session' : justinSession, 'secret' : justinSecret }

  outputDict['message'] = \
'''
To authorize this computer to run the justin command, visit this page with your
usual web browser and follow the instructions within the next 10 minutes:
https://justin%s.dune.hep.ac.uk/authorize/%s

Check that the Session ID displayed on that page is %s

Once you've followed the instructions on that web page, you can run the justin
command without needing to authorize this computer again for 7 days.
''' % ('' if (justin.proDev == 'pro') else ('-' + justin.proDev),
       justinCode, justinSession[:7])
   
  return httpError(startResponse, 
                   '401 Authorization Required',
                   json.dumps(outputDict))

def scopesInfo(startResponse):

  rows = justin.select('SELECT scope_name,wlcg_group_name FROM scopes '
                       'LEFT JOIN wlcg_groups '
                       'ON scopes.wlcg_group_id=wlcg_groups.wlcg_group_id '
                       'ORDER BY scope_name')
  output = ''
  for row in rows:
    
    output += '%s,%s\n' % (row['scope_name'], 
                row['wlcg_group_name'] if row['wlcg_group_name'] else '')

  startResponse('200 OK',
                [('Content-type',  'text/csv'),
                 ('Content-length', str(len(output)))
                ])
  return [output.encode('UTF-8')]

def sitesInfo(startResponse):
  rows   = justin.select('SELECT site_name,enabled '
                         'FROM sites ORDER BY site_name')
  output = ''
  for row in rows:
    output += '%s,%s\n' % (row['site_name'], bool(row['enabled']))

  startResponse('200 OK',
                [('Content-type',  'text/csv'),
                 ('Content-length', str(len(output)))
                ])
  return [output.encode('UTF-8')]

def storagesInfo(startResponse):
  rows   = justin.select('SELECT rse_name,'
                         'rucio_read AND justin_read AS can_read,'
                         'rucio_write AND justin_write AS can_write '
                         'FROM storages '
                         'WHERE NOT decommissioned AND rse_id<>%d '
                         'ORDER BY rse_name' % justin.MonteCarloRseID)
  output = ''
  for row in rows:
    output += '%s,%s,%s\n' % (row['rse_name'], bool(row['can_read']),
                                               bool(row['can_write']))

  startResponse('200 OK',
                [('Content-type',  'text/csv'),
                 ('Content-length', str(len(output)))
                ])
  return [output.encode('UTF-8')]

def sitesStoragesInfo(startResponse):
  rows = justin.select('SELECT site_name,rse_name,distance,sites.enabled,'
                'rucio_read AND justin_read AS can_read,'
                'rucio_write AND justin_write AS can_write '
                'FROM sites_storages '
                'LEFT JOIN sites ON sites.site_id=sites_storages.site_id '
                'LEFT JOIN storages ON storages.rse_id=sites_storages.rse_id '
                'WHERE NOT storages.decommissioned AND '
                'sites_storages.rse_id<>%d '
                'ORDER BY site_name,rse_name' % justin.MonteCarloRseID)
  output = ''
  for row in rows:
    output += '%s,%s,%.02f,%s,%s,%s\n' % (row['site_name'], row['rse_name'], 
                                 row['distance'] / 100.0,
                                 bool(row['enabled']),
                                 bool(row['can_read']), bool(row['can_write']))
  startResponse('200 OK',
                [('Content-type',  'text/csv'),
                 ('Content-length', str(len(output)))
                ])
  return [output.encode('UTF-8')]

#
# Entry point from mod_wsgi
#
def application(environ, startResponse):

  justin.wsgiCallsCount += 1
  print('Call count (pid=%d): %d' % (os.getpid(), justin.wsgiCallsCount), 
        file=sys.stderr)

  try:
    # True should provoke a reconnection attempt.
    # See https://github.com/farcepest/MySQLdb1/blob/master/_mysql.c#L1978
    # (Not sure if there is a more authoritative source for this API.)
    justin.conn.ping(True)
  except Exception as e:
    return httpError(startResponse,
                     '500 Internal Server Error',
                     'DB connection lost and cannot reconnect: ' + str(e))

  # Avoid leftovers from partial, failed transactions in this instance
  # and make sure autocommit is not set
  justin.conn.rollback()
  justin.conn.autocommit(False)

  if environ['REQUEST_URI'] == '/api/info/scopes.csv':
    return scopesInfo(startResponse)

  if environ['REQUEST_URI'] == '/api/info/sites.csv':
    return sitesInfo(startResponse)

  if environ['REQUEST_URI'] == '/api/info/storages.csv':
    return storagesInfo(startResponse)

  if environ['REQUEST_URI'] == '/api/info/sites_storages.csv':
    return sitesStoragesInfo(startResponse)

  # Quickly reject random GETs etc (if not handled by Apache already)
  if environ['REQUEST_METHOD'] != 'POST':
    return httpError(startResponse, 
                     '405 Method not allowed', 
                     'We only support POST')

  try:
    # justin command client always uses POST
    inputLength = int(environ.get('CONTENT_LENGTH', '0'))
    inputString = environ['wsgi.input'].read(inputLength)
    jsonDict = json.loads(inputString)
  except Exception as e:
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'Failed to read and parse JSON')

  # This returns an error if an authorized DN is not found
  user = getUser(jsonDict)

  if not user:
    # No valid session found
    return newSession(startResponse, environ, jsonDict)

  # Check jsonDict specifies a method
  if 'command' not in jsonDict:
    return httpError(startResponse,
                     '400 Bad Request', 
                     'Missing command in JSON')

  if jsonDict['command'] == 'time':
    return timeCmd(startResponse)

  if jsonDict['command'] == 'whoami':
    return whoamiCmd(startResponse, user)

  if jsonDict['command'] == 'show-workflows':
    return showWorkflowsCmd(startResponse, jsonDict)

  if jsonDict['command'] == 'show-stages':
    return showStagesCmd(startResponse, jsonDict)

  if jsonDict['command'] == 'show-jobscript':
    return showJobscriptCmd(startResponse, jsonDict)

  if jsonDict['command'] == 'show-stage-outputs':
    return showStageOutputsCmd(startResponse, jsonDict)

  if jsonDict['command'] == 'show-files':
    return showFilesCmd(startResponse, jsonDict)

  if jsonDict['command'] == 'fail-files':
    return failFilesCmd(startResponse, jsonDict, user)

  if jsonDict['command'] == 'show-replicas':
    return showReplicasCmd(startResponse, jsonDict)

  if jsonDict['command'] == 'create-workflow':
    return createWorkflowCmd(startResponse, jsonDict, user)

  if jsonDict['command'] == 'simple-workflow':
    return simpleWorkflowCmd(startResponse, jsonDict, user)

  if jsonDict['command'] in ['submit-workflow', 'restart-workflow',
                             'pause-workflow', 'finish-workflow']:
    return modifyWorkflowCmds(startResponse, jsonDict, user)

  if jsonDict['command'] == 'create-stage':
    return createStageCmd(startResponse, jsonDict, user)

  if jsonDict['command'] == 'create-jobscript':
    return createJobscriptCmd(startResponse, jsonDict, user)

  if jsonDict['command'] == 'show-jobs':
    return showJobsCmd(startResponse, jsonDict)

  return httpError(startResponse,
                   '400 Bad Request', 
                   'command in JSON not recognised')
