#
# justin-wsgi-ui - justIN commands and info API service
#
# Copyright 2013-24, Andrew McNab for the University of Manchester
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# This WSGI script relies on justin-api-import-script being run by
# the mod_wsgi directive WSGIImportScript

import os
import re
import sys
import ssl
import time
import json
import string
import socket
import urllib
import secrets
import tempfile
import datetime
import subprocess
import urllib.request
import rucio.client
import rucio.client.downloadclient

import justin

def httpError(startResponse, code, message):

  justin.conn.rollback()
  print('justin-wsgi-commands fails with %s (%s)' % 
        (code, str(message)), file=sys.stderr)

  startResponse(code,
                [('Content-type',   'text/plain'),
                 ('Content-length', str(len(message)))
                ])

  return [(message + '\n').encode('UTF-8')]
  
def httpOK(startResponse, message):

  justin.conn.commit()
  startResponse('200 OK',
                [('Content-type',   'text/plain'),
                 ('Content-length', str(len(message)))
                ])

  return [message.encode('UTF-8')]
 
def timeCmd(startResponse):

  return httpOK(startResponse, 
                datetime.datetime.today().strftime('%Y-%m-%d %H:%M:%S UTC\n'))

def whoamiCmd(startResponse, user):

  outputString = \
'''      User name : %s
Session expires : %s UTC
         Groups : %s
''' % (user['user_name'], user['expires_time'], '  '.join(user['wlcg_groups']))

  return httpOK(startResponse, outputString)

def showWorkflowsCmd(startResponse, jsonDict):

  try:
    workflowID = int(jsonDict['workflow_id'])
  except:
    workflowID    = None
    workflowFilter = ""
  else:
    workflowFilter = "WHERE workflow_id=" + str(workflowID)

  try:
    rows = justin.select("SELECT * FROM workflows %s ORDER BY created" 
                         % workflowFilter)
  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error reading justIN database ' + str(e))

  outputString = ''
  for row in rows:
    outputString += ("%5d %-9s %s %s %s\n" % 
                     (row['workflow_id'], row['state'],
                      row['created'], row['description'], row['mql']))

  return httpOK(startResponse, outputString)

def showStagesCmd(startResponse, jsonDict):

  try:
    workflowID = int(jsonDict['workflow_id'])
  except:
    return httpError(startResponse, '400 Bad Request', 'Workflow ID not given')

  try:
    stageID = int(jsonDict['stage_id'])
  except:
    stageID    = None
    stageFilter = ""
  else:
    stageFilter = "AND stage_id=" + str(stageID)

  try:
    rows = justin.select("SELECT * FROM stages WHERE workflow_id=%d %s "
                         "ORDER BY workflow_id,stage_id" 
                         % (workflowID, stageFilter))
  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error reading justIN database ' + str(e))

  outputString = ''
  for row in rows:
    outputString += ("%5d %2d %d %d %d %.1f\n" % 
                     (row['workflow_id'], 
                      row['stage_id'], 
                      row['processors'],
                      row['wall_seconds'],
                      row['rss_bytes'],
                      row['max_distance'],
                    ))

  return httpOK(startResponse, outputString)

def showJobscriptCmd(startResponse, jsonDict):

  gitPathTag = jsonDict.get('jobscript_git', '')

  if gitPathTag:
    # git reference given, so try to go with that

    if not justin.stringIsURL(gitPathTag):
      return ('400 Bad Request', 
              'GitHub reference must be just ORG/PATH/../FILE:TAG')
    try:
      (orgRepoPath, tag) = gitPathTag.split(':', 1)
      (org, repo, path)  = orgRepoPath.split('/', 2)
    except:
      return ('400 Bad Request', 
              'GitHub reference must be ORG/PATH/../FILE:TAG')

    jobscriptGit = '%s/%s/%s:%s' % (org, repo, path, tag)

    url = ('https://raw.githubusercontent.com/%s/%s/%s/%s' 
           % (org, repo, tag, path))
    httpRequest  = urllib.request.Request(url)
    sslContext                = ssl.SSLContext()
#    sslContext.verify_mode    = ssl.CERT_REQUIRED
#    sslContext.check_hostname = True

    try:
      response = urllib.request.urlopen(httpRequest, context = sslContext)
    except Exception as e:
      return ('400 Bad Request', 
              'Get jobscript from GitHub URL %s fails: %s' % (url, str(e)))

    if response.status != 200:
      return ('400 Bad Request', 
              'Get jobscript response not 200, code=%d' % response.status)

    try:
      jobscript = response.read().decode('utf-8')
    except Exception as e:
      return ('400 Bad Request', 'Failed to get jobscript from response')

  else:
    # No git reference, so try workflow/stage

    try:
      workflowID = int(jsonDict['workflow_id'])
    except:
      workflowID = 0

    try:
      stageID = int(jsonDict['stage_id'])
    except:
      stageID = 0

    if not workflowID or not stageID:
      return httpError(startResponse,
                       '400 Bad Request', 
       'Either --jobscript-git or --workflow-id and --stage-id must be given')

    #Â From stage with workflowID and stageID
    query = ('SELECT jobscript FROM stages_jobscripts '
              'WHERE workflow_id=%d AND stage_id=%d'
              % (workflowID, stageID))
  
    try:
      row = justin.select(query, justOne = True)
      jobscript = row['jobscript']
    except Exception as e:
      return httpError(startResponse, 
                       '500 Internal Server Error', 
                       'Error reading justIN database ' + str(e))

  if not jobscript.endswith('\n'):
    jobscript += '\n'

  return httpOK(startResponse, jobscript)

def showStageOutputsCmd(startResponse, jsonDict):

  try:
    workflowID = int(jsonDict['workflow_id'])
  except:
    return httpError(startResponse, '400 Bad Request', 'Workflow ID not given')

  try:
    stageID = int(jsonDict['stage_id'])
  except:
    return httpError(startResponse, '400 Bad Request', 'Stage ID not given')

  try:
    rows = justin.select("SELECT for_next_stage,"
                            "scopes.scope_name,"
                            "file_pattern,"
                            "destination "
                            "FROM stages_outputs "
                            "LEFT JOIN workflows "
                            "ON workflows.workflow_id=stages_outputs.workflow_id "
                            "LEFT JOIN scopes "
                            "ON workflows.scope_id=scopes.scope_id "
                            "WHERE stages_outputs.workflow_id=%d "
                            "AND stages_outputs.stage_id=%d "
                            "ORDER BY destination,file_scope,file_pattern" 
                            % (workflowID, stageID))
  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error reading justIN database ' + str(e))

  outputString = ''
  for row in rows:
    nextStage = '(next)' if row['for_next_stage'] else '(    )'

    outputString += ("%s %s %s %s\n" % (nextStage,
                                        row['scope_name'],
                                        row['file_pattern'],
                                        row['destination']))
   
  return httpOK(startResponse, outputString)

def queryMetaCat(mql):

  try:
    response = urllib.request.urlopen(
                  "%s/data/query?with_meta=no&with_provenance=no" 
                  % justin.metacatServerInputsURL, data = mql.encode() )

    if response.status != 200:
      print("Reading files list from MetaCat for %s fails with HTTP code %d"
            % (mql, response.status), file=sys.stderr)
      return None

    fileLines = response.readlines()
  except Exception as e:    
    print("Reading files list from MetaCat for %s fails with: %s" 
          % (mql, str(e)), 
          file=sys.stderr)
    return None

  fileDIDs = []

  for fileLine in fileLines:
    if fileLine[0] < 32:
      fileLine = fileLine[1:]

    try:
      fileDict = json.loads(fileLine)
    except Exception as e:
      print('JSON parse of %s fails: %s' % (str(fileLine), str(e)))
      return None
    else:
      fileDIDs.append({'scope' : fileDict['namespace'], 
                       'name'  : fileDict['name']       })

  return fileDIDs

def queryRucio(fileDIDs):

  # Check we can talk to Rucio
  try:
    repClient = rucio.client.replicaclient.ReplicaClient()
  except Exception as e:
    print("Connect to Rucio fails with: " + str(e), file=sys.stderr)
    return None
  
  # Use the Rucio API to get a big list of replicas for the files
  try:
    wanRepsList = repClient.list_replicas(fileDIDs,
                                          schemes=['root'], 
                                          domain='wan')

  except Exception as e:
    print("Reading RSE replicas info fails with: " + str(e), file=sys.stderr)
    return None

  output = ''
  for rep in list(wanRepsList):
    for rse in rep['rses']:
      output += '%s:%s %s %s\n' % (rep['scope'],
                                 rep['name'],
                                 rep['rses'][rse][0],
                                 rse)

  return output

def showFilesCmd(startResponse, jsonDict):

  try:
    mql = jsonDict['mql']  
  except:
    mql = None
  
  try:
    workflowID = int(jsonDict['workflow_id'])
  except:
    workflowID = None

  if (mql and workflowID) or (not mql and not workflowID):
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'Workflow ID or MQL must be given (but not both)')

  if mql:
    fileDIDs = queryMetaCat(mql)
    if fileDIDs is None:
      return httpError(startResponse, 
                       '400 Bad Request', 
                       'MQL query error')

    outputString = ''
    for oneDID in fileDIDs[:100]:
      outputString += '%s:%s\n' % (oneDID['scope'], oneDID['name'])
    return httpOK(startResponse, outputString)
  
  filter = ''

  try:
    filter += 'AND files.stage_id=%d ' % int(jsonDict['stage_id'])
  except: 
    pass

  try:
    fileDID = jsonDict['file_did']

    if not justin.stringIsDID(fileDID):
      raise

    filter += 'AND files.file_did="%s" ' % fileDID
  except:
    pass

  try:
    rows = justin.select("SELECT * FROM files "
                            "WHERE workflow_id=%d %s "
                            "AND files.stage_id > 0 "
                            "ORDER BY workflow_id,stage_id,file_did"
                            % (workflowID, filter))
  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error reading justIN database ' + str(e))

  outputString = ''
  for row in rows:
    outputString += ("%d %d %s %s\n" % 
                     (row['workflow_id'],
                      row['stage_id'],
                      row['state'],
                      row['file_did'],
                     )
                    )
   
  return httpOK(startResponse, outputString)

def showReplicasCmd(startResponse, jsonDict):

  try:
    mql = jsonDict['mql']  
  except:
    mql = None
  
  try:
    workflowID = int(jsonDict['workflow_id'])
  except:
    workflowID = None

  if (mql and workflowID) or (not mql and not workflowID):
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'Workflow ID or MQL must be given (but not both)')

  if mql and mql.strip().startswith('monte-carlo '):
    try:
      count = int(mql.strip().split()[1])
    except:
      return httpError(startResponse, 
                       '400 Bad Request', 
                       'Must give integer count with MQL monte-carlo query')

    outputString = ''

    for i in range(1, min(count + 1, 101)):
      outputString += 'monte-carlo-%06d-%06d %06d MONTECARLO\n' % (1, i, i)

    return httpOK(startResponse, outputString)

  if mql:
    fileDIDs = queryMetaCat(mql)
    if fileDIDs is None:
      return httpError(startResponse, 
                       '400 Bad Request', 
                       'MQL query error')

    outputString = queryRucio(fileDIDs)

    if outputString is None:
      return httpError(startResponse, 
                       '400 Bad Request', 
                       'Rucio query error')

    return httpOK(startResponse, outputString)

  filter = ''

  try:
    filter += 'AND files.stage_id=%d ' % int(jsonDict['stage_id'])
  except: 
    pass

  try:
    fileDID = jsonDict['file_did']

    if not justin.stringIsDID(fileDID):
      raise

    filter += 'AND files.file_did="%s" ' % fileDID
  except:
    pass

  try:
    rseName = jsonDict['rse_name']

    if not justin.stringIsSite(rseName):
      raise

    filter += 'AND storages.rse_name="%s" ' % rseName
  except:
    pass

  try:
    rows = justin.select("SELECT replicas.workflow_id,replicas.stage_id,"
                 "files.state,"
                 "storages.rse_name,files.file_did,replicas.wan_pfn "
                 "FROM replicas "
                 "LEFT JOIN storages ON replicas.rse_id=storages.rse_id "
                 "LEFT JOIN files ON replicas.file_id=files.file_id "
                 "WHERE workflow_id=%d %s AND replicas.stage_id > 0 ORDER BY "
                 "files.workflow_id,files.stage_id,files.file_did LIMIT 100"
                 % (workflowID, filter))
  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error reading justIN database ' + str(e))

  outputString = ''
  for row in rows:
    outputString += ("%5d %2d %-11s %s %s %s\n" %
                     (row['workflow_id'],
                      row['stage_id'],
                      row['state'],
                      row['file_did'],
                      row['rse_name'],
                      row['wan_pfn']
                     )
                    )
   
  return httpOK(startResponse, outputString)

def createWorkflow(jsonDict, user, simple = False):

  if 'description' in jsonDict and jsonDict['description']:
    description = jsonDict['description']
  else:
    description = ''

  if 'mql' in jsonDict and jsonDict['mql']:
    mql = jsonDict['mql']
  else:
    mql = ''

  if 'monte_carlo' in jsonDict and jsonDict['monte_carlo']:
    try:
      mql = 'monte-carlo %d' % int(jsonDict['monte_carlo'])
    except:
      return ('400 Bad Request',
              'Monte Carlo option requires an integer count')

  if 'scope' in jsonDict and jsonDict['scope']:
    # --scope option given, so check the scope is known
    scopeName = jsonDict['scope'].lower()
  else:
    scopeName = justin.defaultScopeName

  if not justin.stringIsScope(scopeName):
      return ('400 Bad Request', 
              'Scope name can only be characters a-z 0-9 - _ .')

  try:
      scopeRow = justin.select('SELECT scope_id,wlcg_group_name,'
                          'condor_group_id '
                          'FROM scopes '
                          'LEFT JOIN wlcg_groups '
                          'ON wlcg_groups.wlcg_group_id=scopes.wlcg_group_id '
                          'WHERE scope_name="%s"' % scopeName, 
                          justOne=True)

      wlcgGroupName = scopeRow['wlcg_group_name']
      condorGroupID = int(scopeRow['condor_group_id'])
      scopeID       = int(scopeRow['scope_id'])
      if not scopeID:
        raise
  except:
      return ('400 Bad Request', 
              'Failed to find scope %s in justIN database' % scopeName)
 
  if not wlcgGroupName:
      return ('403 Forbidden', 
              'Scope %s has no group defined and cannot yet be used via justIN'  
              % scopeName)

  if wlcgGroupName not in user['wlcg_groups']:
      return ('403 Forbidden', 
              'You need to be in group %s to use scope %s' % (wlcgGroupName, scopeName))

  refindEnd     = justin.unixEpoch
  refindSeconds = 0

  # Record refind interval if given explicitly
  if 'refind_interval_hours' in jsonDict and jsonDict['refind_interval_hours']:
    try:
      refindSeconds = int(jsonDict['refind_interval_hours']) * 3600
    except:
      return httpError(startResponse, 
                       '400 Bad Request',
                       '--refind-interval-hours requires an integer argument')

  # Record end time if end date is given explicitly
  if 'refind_end_date' in jsonDict and jsonDict['refind_end_date']:
    try:
      yyyymmdd = str(int(jsonDict['refind_end_date']))
      refindEnd = '%s-%s-%s 23:59:59' % (yyyymmdd[0:4],
                                         yyyymmdd[4:6], 
                                         yyyymmdd[6:8])
    except:
      return httpError(startResponse, 
                       '400 Bad Request', 
                       '--refind-end-date requires a YYYYMMDD date')

  # If one of the refind options is given but not the other, use the default

  if refindEnd == justin.unixEpoch and refindSeconds > 0:
    # end time is still unset but we did give --refind-interval-hours
    refindEnd = datetime.datetime.today().strftime('%Y-%m-%d 23:59:59')
  elif refindSeconds == 0 and refindEnd != justin.unixEpoch: 
    # interval seconds is still unset, but we did give an end time
    refindSeconds = 3600

  try:
    workflowID = justin.insertUpdate('INSERT INTO workflows SET created=NOW(),'
          'state="%s",'
          '%s'
          'description="%s",'
          'mql="%s",'
          'scope_id=%d,'
          'condor_group_id=%d,'
          'user_id=%d,'
          'refind_seconds=%d,'
          'refind_end_time="%s" '
          % ('submitted' if simple else 'draft',
             'submitted=NOW(),' if simple else '',
             description,
             mql,
             scopeID,
             condorGroupID,
             user['user_id'],
             refindSeconds,
             refindEnd))
  except Exception as e:
    return ('500 Internal Server Error', 
            'Error creating workflow: ' + str(e))

  if justin.proDev != 'pro' and workflowID >= 1000:
    return ('500 Internal Server Error', 
            'The %s database needs resetting - too many workflows created' 
            % justin.proDev)

  return ('200 OK', workflowID)

def createWorkflowCmd(startResponse, jsonDict, user):

  (code, message) = createWorkflow(jsonDict, user)

  if code == '200 OK':
    return httpOK(startResponse, str(message) + '\n')

  return httpError(startResponse, code, message)

def simpleWorkflowCmd(startResponse, jsonDict, user):

  if 'monte_carlo' in jsonDict and jsonDict['monte_carlo']:
    jsonDict['max_distance'] = 100

  # First create the workflow
  (code, workflowMessage) = createWorkflow(jsonDict, user, simple = True)

  if code != '200 OK':
    return httpError(startResponse, code, workflowMessage)

  # Then create its single stage
  jsonDict['workflow_id'] = int(workflowMessage)
  jsonDict['stage_id']   = 1
  (code, stageMessage) = createStage(jsonDict, user, simple = True, 
                                     scopeName = jsonDict['scope'])

  if code != '200 OK':
    return httpError(startResponse, code, stageMessage)

  # We output the message from the workflow creation
  return httpOK(startResponse, str(workflowMessage) + '\n')

def modifyWorkflowCmds(startResponse, jsonDict, user):
  # Generic handler for restart-workflow, submit-workflow, pause-workflow and
  # finish-workflow

  try:
    workflowID = int(jsonDict['workflow_id'])
  except:
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'Workflow ID must be given')

  try:
    row = justin.select('SELECT workflows.user_id,workflows.state,'
                        'wlcg_group_name FROM workflows '
                        'LEFT JOIN scopes '
                        'ON scopes.scope_id=workflows.scope_id '
                        'LEFT JOIN wlcg_groups '
                        'ON wlcg_groups.wlcg_group_id=scopes.wlcg_group_id '
                        'WHERE workflows.workflow_id=%d' % workflowID,
                        justOne = True)

    workflowUserID = int(row['user_id'])
    workflowState  = row['state']
    wlcgGroupName = row['wlcg_group_name']
  except Exception as e:
    return httpError(startResponse,
                     '500 Internal Server Error',
                     'Database error: ' + str(e))
  
  if workflowUserID != user['user_id'] and \
     user['user_name'] not in justin.justinAdmins and \
     wlcgGroupName not in user['wlcg_groups']:
    return httpError(startResponse,
                     '403 Forbidden',
                     'You do not have permission to update that workflow')
  
  if jsonDict['command'] == 'submit-workflow':
    if workflowState != 'draft':
      return httpError(startResponse,
                   '403 Forbidden',
                   'You cannot submit a workflow that was already submitted')

    # Submitting updates user_id to the person who actually submitted it
    query = ("UPDATE workflows SET "
             "state='submitted',submitted=NOW(),user_id=%d "
             "WHERE workflow_id=%d AND state='draft'" 
             % (workflowID, user['user_id']))

  elif jsonDict['command'] == 'restart-workflow':
    if workflowState != 'paused':
      return httpError(startResponse,
                       '403 Forbidden',
                       'You cannot restart a workflow that is not paused')

    query = ("UPDATE workflows SET state='running' "
             "WHERE workflow_id=%d AND state='paused'"
             % workflowID)

  elif jsonDict['command'] == 'pause-workflow':
    if workflowState != 'running':
      return httpError(startResponse,
                       '403 Forbidden',
                       'You cannot pause a workflow that is not running')

    query = ("UPDATE workflows SET state='paused' "
             "WHERE workflow_id=%d "
             "AND state='running'" % workflowID)

  elif jsonDict['command'] == 'finish-workflow':
    if workflowState not in ('running','submitted','draft'):
      return httpError(startResponse,
                       '403 Forbidden',
                       'You cannot finish a workflow that is not running')

    query = ("UPDATE workflows SET state='finished',finished=NOW() "
             "WHERE workflow_id=%d "
             "AND (state='running' OR state='submitted' OR state='draft')" 
             % workflowID)

  try:
    justin.insertUpdate(query)
  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error updating workflow state: ' + str(e))

  return httpOK(startResponse, '')

def createStage(jsonDict, user, simple = False, scopeName = None):

  try:
    workflowID  = int(jsonDict['workflow_id'])
  except:
    return ('400 Bad Request', 'Workflow ID must be given')

  if not simple:
    # Check reference is to a valid existing workflow
    try:
      workflowRow = justin.select('SELECT workflows.scope_id,scope_name,'
                           'wlcg_group_name,workflows.user_id FROM workflows '
                           'LEFT JOIN scopes '
                           'ON scopes.scope_id=workflows.scope_id '
                           'LEFT JOIN wlcg_groups '
                           'ON wlcg_group.wlcg_group_id=scopes.wlcg_group_id '
                           'WHERE workflow_id=%d' % workflowID, 
                           justOne = True)
      workflowUserID = int(workflowRow['user_id'])
      scopeID       = int(workflowRow['scope_id'])
      scopeName     = workflowRow['scope_name']
      wlcgGroupName = workflowRow['wlcg_group_name']
    except:
      return ('400 Bad Request', 'Valid workflow ID must be given')

    if workflowUserID != user['user_id'] and \
       wlcgGroupName not in user['wlcg_groups']:
      return ('403 Forbidden', 
              'You do not have permission to add a stage to that workflow')

  try:
    stageID = int(jsonDict['stage_id'])
  except:
    return ('400 Bad Request', 'Stage ID must be given')

  try:
    processors = int(jsonDict['processors'])
  except:
    processors = 1

  try:
    needsGPU = jsonDict['gpu']
  except:
    needsGPU = False

  try:
    wallSeconds = int(jsonDict['wall_seconds'])
  except:
    wallSeconds = 80000

  try:
    rssBytes = int(jsonDict['rss_mb']) * 1024 * 1024
  except:
    rssBytes = 2000 * 1024 * 1024

  if 'max_distance' in jsonDict and jsonDict['max_distance']:
    try:
      maxDistance = float(jsonDict['max_distance'])
    except:
      return ('400 Bad Request', '--max-distance option requires a numeric distance')
  else:
    maxDistance = 0.0

  jobscript    = jsonDict.get('jobscript', '')
  jobscriptGit = ''
  gitPathTag   = jsonDict.get('jobscript_git', '')

  if not jobscript and gitPathTag:
    if not justin.stringIsURL(gitPathTag):
      return ('400 Bad Request', 
              'GitHub reference must be just ORG/PATH/../FILE:TAG')
    try:
      (orgRepoPath, tag) = gitPathTag.split(':', 1)
      (org, repo, path)  = orgRepoPath.split('/', 2)
    except:
      return ('400 Bad Request', 
              'GitHub reference must be ORG/PATH/../FILE:TAG')

    jobscriptGit = '%s/%s/%s:%s' % (org, repo, path, tag)

    url = ('https://raw.githubusercontent.com/%s/%s/%s/%s' 
           % (org, repo, tag, path))
    httpRequest  = urllib.request.Request(url)
    sslContext                = ssl.SSLContext()
#    sslContext.verify_mode    = ssl.CERT_REQUIRED
#    sslContext.check_hostname = True

    try:
      response = urllib.request.urlopen(httpRequest, context = sslContext)
    except Exception as e:
      return ('400 Bad Request', 
              'Get jobscript from GitHub URL %s fails: %s' % (url, str(e)))

    if response.status != 200:
      return ('400 Bad Request', 
              'Get jobscript response not 200, code=%d' % response.status)

    try:
      jobscript = response.read().decode('utf-8')
    except Exception as e:
      return ('400 Bad Request', 'Failed to get jobscript from response')

  if not jobscript:
    return ('400 Bad Request',
            '--jobscript or --jobscript-git must by given')

  # Just use the defaults specified in the configuration files for now
  jobscriptImage = (justin.jobscriptImagePrefix + '/' + 
                    justin.jobscriptImageSuffix + ':' + 
                    justin.jobscriptImageVersion)

  try:
    justin.insertUpdate('INSERT INTO stages SET '
                        'stage_priority=50,'
                        'workflow_id=%d,'
                        'stage_id=%d,'
                        'jobscript_git="%s",'
                        'jobscript_image="%s",'
                        'processors=%d,'
                        'needs_gpu=%s,'
                        'wall_seconds=%d,'
                        'rss_bytes=%d,'
                        'max_distance=%f' 
                        % (workflowID, stageID, 
                           jobscriptGit,
                           jobscriptImage,
                           processors, needsGPU, wallSeconds, 
                           rssBytes, maxDistance))
          
    justin.insertUpdate('INSERT INTO stages_jobscripts SET '
                           'workflow_id=%d,'
                           'stage_id=%d,'
                           'jobscript="%s"' 
                           % (workflowID, stageID, 
                         jobscript.replace('\\','\\\\').replace('"','\\"')))

  except Exception as e:
    return ('500 Internal Server Error', 
            'Error updating stages/stages_jobscripts in database ' + str(e))

  justinEnvVars = { 'JUSTIN_WORKFLOW_ID' : str(workflowID),
                    'JUSTIN_STAGE_ID'    : str(stageID)    }

  if scopeName:
    justinEnvVars['JUSTIN_SCOPE'] = scopeName

  patternID      = 1
  outputPatterns = []

  # check output_pattern is not None then proceed with checks
  if jsonDict['output_pattern']:
    for patternDest in jsonDict['output_pattern']:
      if ':' in patternDest:
        (pattern, destination) = patternDest.split(':', 1)
      else:
        # If no dataset given, then will create SCOPE:wNNNNNsNpN 
        pattern     = patternDest
        destination = 'w%ds%dp%d' % (workflowID, stageID, patternID)

      if not destination.startswith('https://') and not scopeName:
        return ('400 Bad Request', 
                'A scope must be specified when creating the workflow if '
                '--output-pattern is given for this stage '
                'and a Rucio dataset is given.')

      destination = justin.expandEnvVars(destination, justinEnvVars)
      outputPatterns.append((False, pattern, destination, patternID))
      patternID += 1

  # check output_pattern_next_stage is not None then proceed with checks
  if jsonDict['output_pattern_next_stage']:
    for patternDest in jsonDict['output_pattern_next_stage']:
      if ':' in patternDest:
        (pattern, destination) = patternDest.split(':', 1)
      else:
        pattern     = patternDest
        destination = 'w%ds%dp%d' % (workflowID, stageID, patternID)
       
      if not scopeName:
        return ('400 Bad Request', 
                'A scope must be specified when creating the workflow if '
                '--output-pattern-next-stage is given for this stage '
                'and a Rucio dataset is given.')

      destination = justin.expandEnvVars(destination, justinEnvVars)
      outputPatterns.append((True, pattern, destination, patternID))
      patternID += 1
    
  try:
    lifetimeDays = int(jsonDict['lifetime_days'])
  except:
    lifetimeDays = 0

  didClient  = rucio.client.didclient.DIDClient()

  for (forNextStage, pattern, destination, patternID) in outputPatterns:

    if not justin.stringIsFilePattern(pattern):
      return ('400 Bad Request', 'Invalid file pattern')

    if destination.startswith('https://'):
        # HTTPS upload URL
   
        if forNextStage:
          return ('400 Bad Request', 
                  'Output for next stage must be within a Rucio dataset')

        if not justin.stringIsURL(destination):
          return ('400 Bad Request', 'Invalid destination URL')

        if destination[-1] == '/':
          destination = destination[:-1]

        # Add Workflow ID and Stage ID to URL
        destination = destination + '/%05d/%d' % (workflowID, stageID)
    else:
        if lifetimeDays == 0:
          try:
            didClient.get_metadata(scope = scopeName, name = destination)

          except rucio.common.exception.DataIdentifierNotFound:
            return ('400 Bad Request',
                    'A lifetime must be specified when creating a stage if '
                    'a Rucio dataset is given that does not yet exist.')
          except:
            return ('400 Bad Request', 
                    'Failed to connect to Rucio server for dataset checks')

        # Rucio dataset name
        if not justin.stringIsDID(destination) or ':' in destination:
          return ('400 Bad Request',
                  'Invalid Rucio dataset name: ' + str(destination))
    try:
        justin.insertUpdate('INSERT INTO stages_outputs SET '
              'workflow_id=%d,'
              'stage_id=%d,'
              'pattern_id=%d,'
              'destination="%s",'
              'file_pattern="%s",'
              'lifetime_seconds=%d,'
              'for_next_stage=%s' % 
              (workflowID, stageID, patternID,
               destination,
               pattern,
               lifetimeDays * 86400,
               forNextStage
              )
             )

    except Exception as e:
        return ('500 Internal Server Error',
                'Error adding stage output: ' + str(e))

  # Store a lowercase version of the preferred output RSEs
  preferredRseNames = []
  if jsonDict['output_rse']:
    for rseName in jsonDict['output_rse']:
      if not justin.stringIsSite(rseName):
        return ('400 Bad Request', 'Invalid RSE name')
      else:
        preferredRseNames.append(rseName.lower())

  # Get a list of all non-decommissioned RSEs
  try:
    rseRows = justin.select('SELECT rse_id,rse_name FROM storages '
                            'WHERE NOT decommissioned AND rse_id<>%d'
                            % justin.MonteCarloRseID)

    justin.insertUpdate('INSERT INTO stages_input_storages SET '
              'workflow_id=%d,'
              'stage_id=%d,'
              'rse_id=%d ' %
              (workflowID, stageID, justin.MonteCarloRseID))
  except Exception as e:
    return ('500 Internal Server Error',
            'Error getting list of RSEs: ' + str(e))

  # We go through all found RSEs, adding them, marking the preferred ones
  for rseRow in rseRows:
    try:
      justin.insertUpdate('INSERT INTO stages_input_storages SET '
              'workflow_id=%d,'
              'stage_id=%d,'
              'rse_id=%d ' %
              (workflowID, stageID, rseRow['rse_id']))

      justin.insertUpdate('INSERT INTO stages_output_storages SET '
              'workflow_id=%d,'
              'stage_id=%d,'
              'rse_id=%d,'
              'preferred=%d' %
              (workflowID, stageID, rseRow['rse_id'],
               True if rseRow['rse_name'].lower() in preferredRseNames 
               else False))

    except Exception as e:
      return ('500 Internal Server Error', 
              'Error adding input/output RSE: ' + str(e))

  # Get a list of all enabled sites
  try:
    siteRows = justin.select('SELECT site_id,site_name FROM sites '
                             'WHERE enabled')
  except Exception as e:
    return ('500 Internal Server Error',
            'Error getting list of sites: ' + str(e))

  # We go through all currently enabled sites, adding them
  for siteRow in siteRows:
    try:
      justin.insertUpdate('INSERT INTO stages_sites SET '
              'workflow_id=%d,'
              'stage_id=%d,'
              'site_id=%d ' %
              (workflowID, stageID, siteRow['site_id']))

    except Exception as e:
      return ('500 Internal Server Error', 
              'Error adding site: ' + str(e))

  if jsonDict['env']:
    for envNameValue in jsonDict['env']:    
      try:        
        (envName,envValue) = envNameValue.split('=',1)
      except:
        return ('400 Bad Request', 'Failed to parse --env option')

      envValue = justin.expandEnvVars(envValue, justinEnvVars)

      if not justin.stringIsEnvName(envName):
        return ('400 Bad Request', 'Invalid environment variable name')

      try:
        justin.insertUpdate('INSERT IGNORE INTO stages_environment SET '
              'workflow_id=%d,'
              'stage_id=%d,'
              'env_name="%s",'
              'env_value="%s"' % 
              (workflowID, 
               stageID, 
               envName, 
               envValue.replace('\\','\\\\').replace('"','\\"')
              ))

      except Exception as e:
        return ('500 Internal Server Error', 
                'Error adding environment variables: ' + str(e))

  if jsonDict['classad']:
    for classadNameValue in jsonDict['classad']:    
      try:        
        (classadName,classadValue) = classadNameValue.split('=',1)
      except:
        return ('400 Bad Request', 'Failed to parse --classad option')

      classadValue = justin.expandEnvVars(classadValue, justinEnvVars)

      if not justin.stringIsEnvName(classadName):
        return ('400 Bad Request', 'Invalid ClassAd name')

      try:
        justin.insertUpdate('INSERT IGNORE INTO stages_classads SET '
              'workflow_id=%d,'
              'stage_id=%d,'
              'classad_name="%s",'
              'classad_value="%s"' % 
              (workflowID, 
               stageID, 
               classadName, 
               classadValue.replace('\\','\\\\').replace('"','\\"')
              ))

      except Exception as e:
        return ('500 Internal Server Error', 
                'Error adding custom ClassAds: ' + str(e))

  if jsonDict['git_repo']:
    for gitRepo in jsonDict['git_repo']:
      if not justin.stringIsURL(gitRepo):
        return ('400 Bad Request', 'Invalid characters in GitHub repo')

      try:
        (gitPath, gitTag) = gitRepo.split(':', 1)
      except:
        return ('400 Bad Request', 
                'GitHub repo must be of the form NAME/REPO:TAG')

      gitPathList = gitPath.split('/')
      if len(gitPathList) != 2 or \
         not gitPathList[0] or \
         not gitPathList[1] or \
         gitPath.endswith('.git'):
        return ('400 Bad Request', 
                'GitHub repo must be of the form NAME/REPO:TAG with one slash '
                'and no .git')

      try:
        tmpDir = tempfile.TemporaryDirectory()

        outcome = subprocess.run('cd %s && '
                        '/usr/bin/git clone --branch %s '
                        '--single-branch https://github.com/%s/%s.git && '
                        'cd %s && '
                        '/usr/bin/git log --pretty=format:"%%H" -n 1 '
                        '--output=../hash.txt'
                        % (tmpDir.name, gitTag, gitPathList[0],
                           gitPathList[1], gitPathList[1]),
                        stdout=subprocess.PIPE, stderr=subprocess.STDOUT, 
                        shell=True
                                )
    
        if outcome.returncode:
          print(outcome.stdout, file=sys.stderr)
          raise RuntimeError('git clone returns error %d' 
                             % outcome.returncode)

        gitCommit = open(tmpDir.name + '/hash.txt', 'r').read().strip()
      except Exception as e:
        
        return ('400 Bad Request',
                'Unable to checkout tag %s from '
                'https://github.com/%s/%s.git: %s'
                % (gitTag, gitPathList[0], gitPathList[1], str(e))
               )

      try:
        justin.insertUpdate('INSERT IGNORE INTO stages_git_repos SET '
              'workflow_id=%d,'
              'stage_id=%d,'
              'git_repo="%s",'
              'git_commit="%s"' %
              (workflowID, 
               stageID, 
               gitRepo,
               gitCommit
              ))

      except Exception as e:
        return ('500 Internal Server Error', 
                'Error adding Git repo: ' + str(e))

  return ('200 OK', '')

def createStageCmd(startResponse, jsonDict, user):

  (code, message) = createStage(jsonDict, user)

  if code == '200 OK':
    return httpOK(startResponse, message)

  return httpError(startResponse, code, message)

def failFilesCmd(startResponse, jsonDict, user):

  try:
    workflowID = int(jsonDict['workflow_id'])
  except:
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'Workflow ID must be given')

  try:
    row = justin.select('SELECT workflows.user_id,wlcg_group_name '
                        'FROM workflows '
                        'LEFT JOIN scopes '
                        'ON scopes.scope_id=workflows.scope_id '
                        'LEFT JOIN wlcg_groups '
                        'ON wlcg_groups.wlcg_group_id=scopes.wlcg_group_id '
                        'WHERE workflows.workflow_id=%d' % workflowID, 
                        justOne = True)

    workflowUserID = row['user_id']
    wlcgGroupName = row['wlcg_group_name']
  except:
    return httpError(startResponse,
                     '500 Internal Server Error',
                     'Database error')
  
  if workflowUserID != user['user_id'] and \
     user['user_name'] not in justin.justinAdmins and \
     wlcgGroupName not in user['wlcg_groups']:
    return httpError(startResponse,
                     '403 Forbidden',
                     'You do not have permission to update that workflow')

  try:
    stageID  = int(jsonDict['stage_id'])
    stageStr = 'AND stage_id=%d' % stageID
  except:
    stageStr = ''

  try:
    justin.insertUpdate('UPDATE files SET state="failed" '
          'WHERE workflow_id=%d %s '
          'AND state IN ("finding", "unallocated", "allocated", "outputting")'
          % (workflowID, stageStr))

  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error marking files as failed: ' + str(e))

  return httpOK(startResponse, '')

def showJobsCmd(startResponse, jsonDict):

  try:
    jobsubID = jsonDict['jobsub_id']
  except:
    jobsubID = None
  
  try:
    workflowID = int(jsonDict['workflow_id'])
  except:
    workflowID = None
  
  try:
    stageID = int(jsonDict['stage_id'])
  except:
    stageID = 1
  
  if jobsubID:
    filter = "WHERE jobsub_id='%s'" % jobsubID 
  elif workflowID:
    filter = "WHERE workflow_id=%d AND stage_id=%d" % (workflowID, stageID)
  else:
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'Either Jobsub ID or Workflow ID must be given')

  if jsonDict['state']:
    try:  
      filter += (' AND job_state="' +
                 re.sub('[^a-z]+', '', str(jsonDict['state'])) +
                 '"'
                )
    except:
      pass

  try:
    rows = justin.select("SELECT jobsub_id,workflow_id,stage_id,"
                         "job_state,allocation_time "
                         "FROM jobs "
                         + filter +
                         " ORDER BY justin_job_id")
  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error reading justIN database ' + str(e))

  outputString = ''
  for row in rows:
    outputString += ("%30s %5s %2s %10s  %s\n" % 
                     (row['jobsub_id'], row['workflow_id'], row['stage_id'], 
                      row['job_state'], row['allocation_time']))
   
  return httpOK(startResponse, outputString)

def fetchLogsCmd(startResponse, jsonDict):

  try:
    jobsubID = jsonDict['jobsub_id']
  except:
    return httpError(startResponse, 
                     '400 Bad Request', 'Jobsub ID must be given')

  if not justin.stringIsJobsubID(jobsubID):
    return httpError(startResponse, 
                     '400 Bad Request', 'Not a valid jobsub ID')

  try:
    client         = rucio.client.Client(timeout = 60)
    downloadClient = rucio.client.downloadclient.DownloadClient(client)
  except Exception as e:
    print('Failed to connect to Rucio: ' + str(e), file=sys.stderr)
    return httpError(startResponse, '500 Internal Server Error', 
                     'justIN server failed to connect to Rucio')
    
  try:
    tmpDir = tempfile.TemporaryDirectory()
    downloadClient.download_dids([
         { 'did' : 'justin-logs:%s.logs.tgz' % jobsubID.replace('@','-'),
           'transfer_timeout' : 60,
           'base_dir'         : tmpDir.name,
           'no_subdir'        : True } ])
  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Fetching logs.tgz fails with Rucio error: ' + str(e))

  try:
    message = open(tmpDir.name + 
                   '/%s.logs.tgz' % jobsubID.replace('@','-'), 'rb').read()
  except:
    return httpError(startResponse, '500 Internal Server Error', 
                     'justIN server failed to read spooled logs.tgz')

  startResponse('200 OK',
                [('Content-type',   'application/gzip'),
                 ('Content-length', str(len(message)))
                ])

  return [message]

#
# Start of utility functions
#
def getUser(jsonDict):

  try:
    session = jsonDict['session']
    secret  = jsonDict['secret']

    if not session or not secret or \
       not justin.stringIsSite(session) or not justin.stringIsSite(secret):
      raise
  except:
    return None

  try:
    row = justin.select(
           'SELECT principal_name,sessions.user_id,'
           'sessions.wlcg_groups,expires_time '
           'FROM sessions '
           'LEFT JOIN users ON users.user_id=sessions.user_id '
           'LEFT JOIN principal_names '
           'ON principal_names.pn_id=users.main_pn_id '
           'WHERE justin_session="%s" AND justin_secret="%s" AND '
           'sessions.user_id<>0 AND sessions.expires_time > NOW() '
           'AND session_type="command"' % (session, secret),
           justOne = True)
  
    userID         = int(row['user_id'])
    userName       = row['principal_name']
    wlcgGroups     = row['wlcg_groups'].split()
    expiresTime    = row['expires_time']
  except Exception as e:
    print('Finding session fails with: ' + str(e), file=sys.stderr)
    return None

  return { 'user_id'         : userID,
           'user_name'       : userName,
           'expires_time'    : expiresTime,
           'wlcg_groups'     : wlcgGroups }

def newSession(startResponse, environ, jsonDict):
  
  justinSession = secrets.token_urlsafe(64)
  justinSecret  = secrets.token_urlsafe(64)
  justinCode    = secrets.token_urlsafe(25)
  savedURI      = '/dashboard/'
  userAgent     = environ.get('HTTP_USER_AGENT', '')
  ip            = environ.get('REMOTE_ADDR', '')
  hostname      = ''

  if ip:
    try:
      hostname = socket.gethostbyaddr(ip)[0]
    except:
      pass

  try:
    justin.insertUpdate('INSERT INTO sessions SET '
                        'session_type="command",'
                        'created_time=NOW(),'
                        'expires_time=DATE_ADD(NOW(),INTERVAL 10 MINUTE),'
                        'justin_session="%s",'
                        'justin_secret="%s",'
                        'justin_code="%s",'
                        'user_agent="%s",'
                        'saved_uri="%s",'
                        'ip="%s",'
                        'hostname="%s",'
                        'os_release="%s"'
                        % (justinSession, justinSecret, justinCode,
                           userAgent.replace('\\','\\\\').replace('"','\\"'),
                           savedURI,
                           ip, hostname,
              jsonDict['os_release'].replace('\\','\\\\').replace('"','\\"') ))
    justin.conn.commit()
  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Failed creating session: ' + str(e))

  outputDict = { 'session' : justinSession, 'secret' : justinSecret }

  outputDict['message'] = \
'''
To authorize this computer to run the justin command, visit this page with your
usual web browser and follow the instructions within the next 10 minutes:
https://justin%s.dune.hep.ac.uk/authorize/%s

Check that the Session ID displayed on that page is %s

Once you've followed the instructions on that web page, you can run the justin
command without needing to authorize this computer again for 7 days.
''' % ('' if (justin.proDev == 'pro') else ('-' + justin.proDev),
       justinCode, justinSession[:7])
   
  return httpError(startResponse, 
                   '401 Authorization Required',
                   json.dumps(outputDict))

def scopesInfo(startResponse):

  rows = justin.select('SELECT scope_name,wlcg_group_name FROM scopes '
                       'LEFT JOIN wlcg_groups '
                       'ON scopes.wlcg_group_id=wlcg_groups.wlcg_group_id '
                       'ORDER BY scope_name')
  output = ''
  for row in rows:
    
    output += '%s,%s\n' % (row['scope_name'], 
                row['wlcg_group_name'] if row['wlcg_group_name'] else '')

  startResponse('200 OK',
                [('Content-type',  'text/csv'),
                 ('Content-length', str(len(output)))
                ])
  return [output.encode('UTF-8')]

def sitesInfo(startResponse):
  rows   = justin.select('SELECT site_name,enabled '
                         'FROM sites ORDER BY site_name')
  output = ''
  for row in rows:
    output += '%s,%s\n' % (row['site_name'], bool(row['enabled']))

  startResponse('200 OK',
                [('Content-type',  'text/csv'),
                 ('Content-length', str(len(output)))
                ])
  return [output.encode('UTF-8')]

def storagesInfo(startResponse):
  rows   = justin.select('SELECT rse_name,'
                         'rucio_read AND justin_read AS can_read,'
                         'rucio_write AND justin_write AS can_write '
                         'FROM storages '
                         'WHERE NOT decommissioned AND rse_id<>%d '
                         'ORDER BY rse_name' % justin.MonteCarloRseID)
  output = ''
  for row in rows:
    output += '%s,%s,%s\n' % (row['rse_name'], bool(row['can_read']),
                                               bool(row['can_write']))

  startResponse('200 OK',
                [('Content-type',  'text/csv'),
                 ('Content-length', str(len(output)))
                ])
  return [output.encode('UTF-8')]

def sitesStoragesInfo(startResponse):
  rows = justin.select('SELECT site_name,rse_name,distance,sites.enabled,'
                'rucio_read AND justin_read AS can_read,'
                'rucio_write AND justin_write AS can_write '
                'FROM sites_storages '
                'LEFT JOIN sites ON sites.site_id=sites_storages.site_id '
                'LEFT JOIN storages ON storages.rse_id=sites_storages.rse_id '
                'WHERE NOT storages.decommissioned AND '
                'sites_storages.rse_id<>%d '
                'ORDER BY site_name,rse_name' % justin.MonteCarloRseID)
  output = ''
  for row in rows:
    output += '%s,%s,%.02f,%s,%s,%s\n' % (row['site_name'], row['rse_name'], 
                                 row['distance'] / 100.0,
                                 bool(row['enabled']),
                                 bool(row['can_read']), bool(row['can_write']))
  startResponse('200 OK',
                [('Content-type',  'text/csv'),
                 ('Content-length', str(len(output)))
                ])
  return [output.encode('UTF-8')]

#
# Entry point from mod_wsgi
#
def application(environ, startResponse):

  justin.wsgiCallsCount += 1
  print('Call count (pid=%d): %d' % (os.getpid(), justin.wsgiCallsCount), 
        file=sys.stderr)

  justin.readConf()

  try:
    # True should provoke a reconnection attempt.
    # See https://github.com/farcepest/MySQLdb1/blob/master/_mysql.c#L1978
    #Â (Not sure if there is a more authoritative source for this API.)
    justin.conn.ping(reconnect = True)
  except Exception as e:
    return httpError(startResponse,
                     '500 Internal Server Error',
                     'DB connection lost and cannot reconnect: ' + str(e))

  # Avoid leftovers from partial, failed transactions in this instance
  # and make sure autocommit is not set
  justin.conn.rollback()
  justin.conn.autocommit(False)
 
  justin.checkProxyStrings()

  if environ['REQUEST_URI'] == '/api/info/scopes.csv':
    return scopesInfo(startResponse)

  if environ['REQUEST_URI'] == '/api/info/sites.csv':
    return sitesInfo(startResponse)

  if environ['REQUEST_URI'] == '/api/info/storages.csv':
    return storagesInfo(startResponse)

  if environ['REQUEST_URI'] == '/api/info/sites_storages.csv':
    return sitesStoragesInfo(startResponse)

  # Quickly reject random GETs etc (if not handled by Apache already)
  if environ['REQUEST_METHOD'] != 'POST':
    return httpError(startResponse, 
                     '405 Method not allowed', 
                     'We only support POST')

  try:
    # justin command client always uses POST
    inputLength = int(environ.get('CONTENT_LENGTH', '0'))
    inputString = environ['wsgi.input'].read(inputLength)
    jsonDict = json.loads(inputString)
  except Exception as e:
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'Failed to read and parse JSON')

  # This returns an error if an authorized DN is not found
  user = getUser(jsonDict)

  if not user:
    # No valid session found
    return newSession(startResponse, environ, jsonDict)

  # Check jsonDict specifies a method
  if 'command' not in jsonDict:
    return httpError(startResponse,
                     '400 Bad Request', 
                     'Missing command in JSON')

  if jsonDict['command'] == 'time':
    return timeCmd(startResponse)

  if jsonDict['command'] == 'whoami':
    return whoamiCmd(startResponse, user)

  if jsonDict['command'] == 'show-workflows':
    return showWorkflowsCmd(startResponse, jsonDict)

  if jsonDict['command'] == 'show-stages':
    return showStagesCmd(startResponse, jsonDict)

  if jsonDict['command'] == 'show-jobscript':
    return showJobscriptCmd(startResponse, jsonDict)

  if jsonDict['command'] == 'show-stage-outputs':
    return showStageOutputsCmd(startResponse, jsonDict)

  if jsonDict['command'] == 'show-files':
    return showFilesCmd(startResponse, jsonDict)

  if jsonDict['command'] == 'fail-files':
    return failFilesCmd(startResponse, jsonDict, user)

  if jsonDict['command'] == 'show-replicas':
    return showReplicasCmd(startResponse, jsonDict)

  if jsonDict['command'] == 'create-workflow':
    return createWorkflowCmd(startResponse, jsonDict, user)

  if jsonDict['command'] == 'simple-workflow':
    return simpleWorkflowCmd(startResponse, jsonDict, user)

  if jsonDict['command'] in ['submit-workflow', 'restart-workflow',
                             'pause-workflow', 'finish-workflow']:
    return modifyWorkflowCmds(startResponse, jsonDict, user)

  if jsonDict['command'] == 'create-stage':
    return createStageCmd(startResponse, jsonDict, user)

  if jsonDict['command'] == 'create-jobscript':
    return createJobscriptCmd(startResponse, jsonDict, user)

  if jsonDict['command'] == 'show-jobs':
    return showJobsCmd(startResponse, jsonDict)

  if jsonDict['command'] == 'fetch-logs':
    return fetchLogsCmd(startResponse, jsonDict)

  return httpError(startResponse,
                   '400 Bad Request', 
                   'command in JSON not recognised')
