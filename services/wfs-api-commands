#
#  wfs-api-commands - Workflow System commands API service
#
#  Andrew McNab, University of Manchester.
#  Copyright (c) 2013-22. All rights reserved.
#
#  Redistribution and use in source and binary forms, with or
#  without modification, are permitted provided that the following
#  conditions are met:
#
#    o Redistributions of source code must retain the above
#      copyright notice, this list of conditions and the following
#      disclaimer. 
#    o Redistributions in binary form must reproduce the above
#      copyright notice, this list of conditions and the following
#      disclaimer in the documentation and/or other materials
#      provided with the distribution. 
#
#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
#  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
#  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
#  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
#  BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
#  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
#  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
#  ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
#  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
#  OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#  POSSIBILITY OF SUCH DAMAGE.

#  This WSGI script relies on wfs-api-import-script being run by
#  the mod_wsgi directive WSGIImportScript

#  This WSGI script must be run from an Apache httpd server with
#  X.509 proxy certificates enabled. On a systemd system (like 
#  CentOS 7) you need to enable this in OpenSSL inside mod_ssl
#  by adding this line to /usr/lib/systemd/system/httpd.service
#  in the [Service] section:
#
#  Environment=OPENSSL_ALLOW_PROXY_CERTS=1

import re
import sys
import time
import json
import string
import datetime

import wfs

def httpError(startResponse, code, message):

  wfs.db.conn.rollback()

  if code[:3] != '200':
    print('wfdb-cgi fails with %s (%s)' % 
          (code, str(message)), file=sys.stderr)

  startResponse(code,
                [('Content-type',   'text/plain'),
                 ('Content-length', str(len(message)))
                ])

  return [message.encode('UTF-8')]
  
def httpOK(startResponse, outputString):

  wfs.db.conn.commit()
  startResponse('200 OK',
                [('Content-type',   'text/plain'),
                 ('Content-length', str(len(outputString)))
                ])

  return [outputString.encode('UTF-8')]
  
def showRequestsCmd(startResponse, jsonDict):

  try:
    requestID = int(jsonDict['request_id'])
  except:
    requestID    = None
    requestFilter = ""
  else:
    requestFilter = "WHERE request_id=" + str(requestID)

  try:
    rows = wfs.db.select("SELECT * FROM requests %s ORDER BY created" 
                         % requestFilter)
  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error reading workflow database ' + str(e))

  outputString = ''
  for row in rows:
    outputString += ("%5d %-9s %s %s %s\n" % 
                     (row['request_id'], row['state'],
                      row['created'], row['name'], row['mql']))

  return httpOK(startResponse, outputString)

def showStagesCmd(startResponse, jsonDict):

  try:
    requestID = int(jsonDict['request_id'])
  except:
    return httpError(startResponse, '400 Bad Request', 'Request ID not given')

  try:
    stageID = int(jsonDict['stage_id'])
  except:
    stageID    = None
    stageFilter = ""
  else:
    stageFilter = "AND stage_id=" + str(stageID)

  try:
    rows = wfs.db.select("SELECT * FROM stages WHERE request_id=%d %s "
                         "ORDER BY request_id,stage_id" 
                         % (requestID, stageFilter))
  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error reading workflow database ' + str(e))

  outputString = ''
  for row in rows:
    outputString += ("%5d %2d %d %d %d %.1f\n" % 
                     (row['request_id'], 
                      row['stage_id'], 
                      row['processors'],
                      row['wall_seconds'],
                      row['rss_bytes'],
                      row['max_distance'],
                    ))

  return httpOK(startResponse, outputString)

def showBootstrapCmd(startResponse, jsonDict):

  try:
    requestID = int(jsonDict['request_id'])
  except:
    return httpError(startResponse, '400 Bad Request', 'Request ID not given')

  try:
    stageID = int(jsonDict['stage_id'])
  except:
    return httpError(startResponse, '400 Bad Request', 'Stage ID not given')

  try:
    rows = wfs.db.select("SELECT * FROM bootstraps "
                         "WHERE request_id=%d AND stage_id=%d"
                         % (requestID, stageID))
  except Exception as e:
   return httpError(startResponse, 
                    '500 Internal Server Error', 
                    'Error reading workflow database ' + str(e))

  return httpOK(startResponse, rows[0]['bootstrap'])

def showStageOutputsCmd(startResponse, jsonDict):

  try:
    requestID = int(jsonDict['request_id'])
  except:
    return httpError(startResponse, '400 Bad Request', 'Request ID not given')

  try:
    stageID = int(jsonDict['stage_id'])
  except:
    return httpError(startResponse, '400 Bad Request', 'Stage ID not given')

  try:
    rows = wfs.db.select("SELECT * FROM stages_outputs "
                         "WHERE request_id=%d AND stage_id=%d "
                         "ORDER BY dataset,file_scope,file_pattern" 
                         % (requestID, stageID))
  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error reading workflow database ' + str(e))

  outputString = ''
  for row in rows:
    nextStage = '(next)' if row['for_next_stage'] else '(    )'
    outputString += ("%s %s %s %s\n" % (nextStage,
                                        row['dataset'],
                                        row['file_scope'],
                                        row['file_pattern']))
   
  return httpOK(startResponse, outputString)

def showFilesCmd(startResponse, jsonDict):

  try:
    requestID = int(jsonDict['request_id'])
  except:
    requestID = None

  try:
    stageID = int(jsonDict['stage_id'])
  except:
    stageID = None

  try:
    fileDID = jsonDict['file_did']
  except:
    fileDID = None

  if fileDID is None and requestID is None:
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'Either file DID or request ID must be given')

  if fileDID and not requestID:
    filter = "file_did='%s'" % fileDID
  elif requestID:
    filter = "request_id=%d" % requestID
    
    if stageID:
      filter += " AND stage_id=%d" % stageID
    
    if fileDID:
      filter += " AND file_did='%s'" % fileDID

  try:
    rows = wfs.db.select("SELECT * FROM files WHERE " + filter +
                         " ORDER BY request_id,stage_id,file_did")
  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error reading workflow database ' + str(e))

  outputString = ''
  for row in rows:
    outputString += ("%5d %2d %-11s %s\n" % 
                     (row['request_id'],
                      row['stage_id'],
                      row['state'],
                      row['file_did'],
                     )
                    )
   
  return httpOK(startResponse, outputString)

def showReplicasCmd(startResponse, jsonDict):

  try:
    requestID = int(jsonDict['request_id'])
  except:
    requestID = None

  try:
    stageID = int(jsonDict['stage_id'])
  except:
    stageID = None

  if 'file_did' in jsonDict and jsonDict['file_did']:
    fileDID = jsonDict['file_did']
  else:
    fileDID = None

  try:
    rseName = re.sub('[^A-Za-z0-9._-]+', '', str(jsonDict['rse_name'][0]))
  except:
    rseName = None
    
  if fileDID is None and requestID is None:
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'Either file DID or request ID must be given')

  if fileDID and not requestID:
    filter = "files.file_did='%s'" % fileDID
  elif requestID:
    filter = "files.request_id=%d" % requestID
    
    if stageID:
      filter += " AND files.stage_id=%d" % stageID
    
    if fileDID:
      filter += " AND files.file_did='%s'" % fileDID

  if rseName:
    filter += " AND storages.rse_name='%s'" % rseName

  try:
    rows = wfs.db.select("SELECT replicas.request_id,replicas.stage_id,"
                         "files.state,"
                         "storages.rse_name,files.file_did "
                 "FROM replicas "
                 "LEFT JOIN storages ON replicas.rse_id=storages.rse_id "
                 "LEFT JOIN files ON replicas.file_id=files.file_id "
                 "WHERE " + filter + " ORDER BY "
                 "files.request_id,files.stage_id,files.file_did")
  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error reading workflow database ' + str(e))

  outputString = ''
  for row in rows:
    outputString += ("%5d %2d %-11s %-15s %s\n" % 
                     (row['request_id'],
                      row['stage_id'],
                      row['state'],
                      row['rse_name'],           
                      row['file_did']
                     )
                    )
   
  return httpOK(startResponse, outputString)

def showStoragesCmd(startResponse, jsonDict):

  try:
    rseName = re.sub('[^A-Za-z0-9._-]+', '', str(jsonDict['rse_name'][0]))
    filter  = "WHERE rse_name='%s'" % rseName
  except:
    filter = ""

  try:
    rows = wfs.db.select("SELECT * FROM storages " + filter + 
                         " ORDER BY rse_name,occupancy")
  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error reading workflow database ' + str(e))

  outputString = ''
  for row in rows:
    availabilityList = ['-', '-', '-']

    if row['rse_read']:
      availabilityList[0] = 'R'
  
    if row['rse_write']:
      availabilityList[1] = 'W'
  
    if row['rse_delete']:
      availabilityList[2] = 'D'  
      
    if row['use_for_output']:
      useForOutput = 'Y'
    else:
      useForOutput = 'N'

    outputString += ("%-25s %.2f  %s %s\n" % 
                     (row['rse_name'], row['occupancy'], 
                      ''.join(availabilityList), useForOutput))

  return httpOK(startResponse, outputString)

def showSitesStoragesCmd(startResponse, jsonDict):

  if 'site_name' in jsonDict and jsonDict['site_name']:
    siteName = jsonDict['site_name']
  else:
    siteName = None

  try:
    rseName = re.sub('[^A-Za-z0-9._-]+', '', str(jsonDict['rse_name'][0]))
  except:
    rseName = None
    
  if siteName and rseName:
    filter = "WHERE site_name='%s' AND rse_name='%s'" % (siteName, rseName)
  elif siteName:
    filter = "WHERE site_name='%s'" % siteName
  elif rseName:
    filter = "WHERE rse_name='%s'" % rseName
  else:
    filter = ""

  try:
    rows = wfs.db.select("SELECT * FROM sites_storages " 
                "LEFT JOIN storages ON sites_storages.rse_id=storages.rse_id "
                "LEFT JOIN sites ON sites_storages.site_id=sites.site_id "
                + filter +          
                " ORDER BY site_name,rse_name")
  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error reading workflow database ' + str(e))

  outputString = ''
  for row in rows:
    outputString += ("%-20s %-22s %5.1f\n" % 
                     (row['site_name'], row['rse_name'],
                      row['distance']))
   
  return httpOK(startResponse, outputString)

def createRequestCmd(startResponse, jsonDict, userID):

  if 'name' in jsonDict and jsonDict['name']:
    name = jsonDict['name']
  else:
    name = str(int(time.time()))

  if 'mql' in jsonDict and jsonDict['mql']:
    mql = jsonDict['mql']
  else:
    mql = ''

  if 'monte_carlo' in jsonDict and jsonDict['monte_carlo']:
    try:
      mql = 'monte-carlo %d' % int(jsonDict['monte_carlo'])
    except:
      return httpError(startResponse, 
                       '400 Bad Request', 
                       'Monte Carlo option requires an integer count')

  if 'refind_interval_hours' in jsonDict and jsonDict['refind_interval_hours']:
    try:
      refindIntervalSeconds = int(jsonDict['refind_interval_hours'] * 3600)
    except:
      return httpError(startResponse, 
                       '400 Bad Request', 
                       '--refind-interval-hours requires an integer argument')
  else:
    refindIntervalSeconds = 0

  if 'refind_start_date' in jsonDict and jsonDict['refind_start_date']:
    try:
      yyyymmdd = str(int(jsonDict['refind_start_date']))
      refindStartDate = '%s-%s-%s 00:00:00' % (yyyymmdd[0:4], 
                                               yyyymmdd[4:6], 
                                               yyyymmdd[6:8])
    except:
      return httpError(startResponse, 
                       '400 Bad Request', 
                       '--refind-start-date requires a YYYYMMDD date')
  else:
    refindStartDate = datetime.datetime.today().strftime('%Y-%m-%d 00:00:00')

  if 'refind_duration_days' in jsonDict and jsonDict['refind_duration_days']:
    try:
      refindDurationDays = int(jsonDict['refind_duration_days'])
      refindFinishDate = (
                          datetime.datetime.today() +
                          datetime.timedelta(refindDurationDays)
                         ).strftime('%Y-%m-%d 23:59:59')
    except:
      return httpError(startResponse,
                       '400 Bad Request', 
                       '--refind-duration-days requires an integeer')
  else:
    refindDurationDays = 1

  try:
    requestID = wfs.db.insertUpdate('INSERT INTO requests SET created=NOW(),'
          'name="%s",'
          'mql="%s",'
          'user_id=%d,'
          'refind_seconds=%d,'
          'refind_start_time="%s",'
          'refind_end_time="%s"' %
          (name,
           mql,
           userID,
           refindIntervalSeconds,
           refindStartDate,
           refindFinishDate))
  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error updating workflow database ' + str(e))

  return httpOK(startResponse, str(requestID))

def quickRequestCmd(startResponse, jsonDict, userID):

  if 'name' in jsonDict and jsonDict['name']:
    name = jsonDict['name']
  else:
    name = str(int(time.time()))

  if 'mql' in jsonDict and jsonDict['mql']:
    mql = jsonDict['mql']
  else:
    mql = ''

  if 'max_distance' in jsonDict and jsonDict['max_distance']:
    try:
      maxDistance = float(jsonDict['max_distance'])
    except:
      return httpError(startResponse, 
                       '400 Bad Request',
                       '--max-distance option requires a numeric distance')
  else:
    maxDistance = 0.0

  if 'monte_carlo' in jsonDict and jsonDict['monte_carlo']:
    try:
      mql = 'monte-carlo %d' % int(jsonDict['monte_carlo'])
      maxDistance = 100.0
    except:
      return httpError(startResponse, 
                       '400 Bad Request', 
                       'Monte Carlo option requires an integer count')
      
  if 'refind_hours' in jsonDict and jsonDict['refind_hours']:
    try:
      refindSeconds = int(jsonDict['refind_hours'] * 3600)
    except:
      return httpError(startResponse, 
                       '400 Bad Request', 
                       '--refind-hours requires an integer argument')
  else:
    refindSeconds = 0

  if 'refind_start' in jsonDict and jsonDict['refind_start']:
    try:
      yyyymmdd = str(int(jsonDict['refind_start']))
      refindStart = '%s-%s-%s 00:00:00' % (yyyymmdd[0:4], 
                                           yyyymmdd[4:6], 
                                           yyyymmdd[6:8])
    except:
      return httpError(startResponse, 
                       '400 Bad Request', 
                       '--refind-start requires a YYYYMMDD date')
  else:
    refindStart = datetime.datetime.today().strftime('%Y-%m-%d 00:00:00')

  if 'refind_end' in jsonDict and jsonDict['refind_end']:
    try:
      yyyymmdd = str(int(jsonDict['refind_end']))
      refindEnd = '%s-%s-%s 00:00:00' % (yyyymmdd[0:4], 
                                         yyyymmdd[4:6], 
                                         yyyymmdd[6:8])
    except:
      return httpError(startResponse, 
                       '400 Bad Request', 
                       '--refind-end requires a YYYYMMDD date')
  else:
    refindEnd = datetime.datetime.today().strftime('%Y-%m-%d 23:59:59')
      

  try:
    requestID = wfs.db.insertUpdate('INSERT INTO requests SET created=NOW(),'
          'submitted=NOW(),'
          'started=NOW(),'
          'state="running",'
          'name="%s",'
          'mql="%s",'
          'user_id=%d,'
          'refind_seconds=%d,'
          'refind_start_time="%s",'
          'refind_end_time="%s"' %
          (name,
           mql,
           userID,
           refindSeconds,
           refindStart,
           refindEnd))
  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error updating workflow database ' + str(e))

  try:
    processors = int(jsonDict['processors'])
  except:
    processors = 1

  try:
    wallSeconds = int(jsonDict['wall_seconds'])
  except:
    wallSeconds = 80000

  try:
    rssBytes = int(jsonDict['rss_mb']) * 1024 * 1024
  except:
    rssBytes = 2000 * 1024 * 1024

  if 'file' in jsonDict and jsonDict['file']:
    bootstrap = jsonDict['file']
  else:
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'Upload file is required')

  try:
    wfs.db.insertUpdate("INSERT INTO stages SET "
          "request_id=%d,"
          "stage_id=1,"
          "processors=%d,"
          "wall_seconds=%d,"
          "rss_bytes=%d,"
          "max_distance=%f" % 
          (requestID, processors,
           wallSeconds, rssBytes, maxDistance))
          
    wfs.db.insertUpdate('INSERT INTO bootstraps SET '
          'request_id=%d,'
          'stage_id=1,'
          'bootstrap="%s"' % 
          (requestID, 
           bootstrap.replace('\\','\\\\').replace('"','\\"')))
  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error updating workflow database ' + str(e))

  try:
    lifetimeDays = int(jsonDict['lifetime_days'])
  except:
    lifetimeDays = 1

  if jsonDict['output_pattern']:
    for i in jsonDict['output_pattern']:
      splitList = i.split(':')
       
      if len(splitList) < 3:
        continue
    
      scope        = splitList[0]
      datasetName  = splitList[1]
      pattern      = ':'.join(splitList[2:])

      try:
        wfs.db.insertUpdate('INSERT INTO stages_outputs SET '
              'request_id=%d,'
              'stage_id=1,'
              'dataset="%s:%s",'
              'file_scope="%s",'
              'file_pattern="%s",'
              'lifetime_seconds=%d,'
              'for_next_stage=FALSE' % 
              (requestID,
               scope.replace('\\','\\\\').replace('"','\\"'),
               datasetName.replace('\\','\\\\').replace('"','\\"'),
               scope.replace('\\','\\\\').replace('"','\\"'),
               pattern.replace('\\','\\\\').replace('"','\\"'),
               lifetimeDays * 86400
              )
             )
      except Exception as e:
        return httpError(startResponse, 
                        '500 Internal Server Error', 
                        'Error updating workflow database ' + str(e))

  if jsonDict['output_rse']:
    for rseName in jsonDict['output_rse']:
    
      if not wfs.db.stringIsSite(rseName):
        return httpError(startResponse, '400 Bad Request', 'Invalid RSE name')

      try:
        wfs.db.insertUpdate('INSERT INTO stages_output_storages SET '
              'request_id=%d,'
              'stage_id=1,'
              'rse_id=(SELECT rse_id FROM storages WHERE rse_name="%s")' % 
              (requestID, rseName))
      except Exception as e:
        return httpError(startResponse, 
                         '500 Internal Server Error', 
                          'Error updating workflow database ' + str(e))

  return httpOK(startResponse, str(requestID))

def submitRequestCmd(startResponse, jsonDict):

  try:
    requestID = int(jsonDict['request_id'])
  except:
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'Request ID must be given')

# change to handle errors properly eg no such request
# and state not draft
  try:
    wfs.db.insertUpdate("UPDATE requests SET "
                        "state='submitted',submitted=NOW() "
                        "WHERE request_id=%d AND state='draft'" % requestID)
  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error updating workflow database ' + str(e))

  return httpOK(startResponse, '')

def startRequestCmd(startResponse, jsonDict):

  try:
    requestID = int(jsonDict['request_id'])
  except:
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'Request ID must be given')

# change to handle errors properly eg no such request
# or not in draft or submitted states
  try:
    wfs.db.insertUpdate("UPDATE requests SET started=NOW() "
          "WHERE request_id=%d AND "
          "(state='draft' OR state='submitted')"
          % requestID)

    wfs.db.insertUpdate("UPDATE requests SET state='running' "
          "WHERE request_id=%d AND "
          "(state='draft' OR state='submitted' OR state='paused')"
          % requestID)

  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error updating workflow database ' + str(e))

  return httpOK(startResponse, '')

def pauseRequestCmd(startResponse, jsonDict):

  try:
    requestID = int(jsonDict['request_id'])
  except:
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'Request ID must be given')

# change to handle errors properly eg no such request
  try:
    wfs.db.insertUpdate("UPDATE requests SET state='paused' "
                        "WHERE request_id=%d "
                        "AND state='running'" % requestID)

  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error updating workflow database ' + str(e))

  return httpOK(startResponse, '')

def finishRequestCmd(startResponse, jsonDict):

  try:
    requestID = int(jsonDict['request_id'])
  except:
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'Request ID must be given')

# change to handle errors properly eg no such request
  try:
    wfs.db.insertUpdate("UPDATE requests SET state='finished' "
                        "WHERE request_id=%d "
                        "AND state<>'deleted'" % requestID)

  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error updating workflow database ' + str(e))

  return httpOK(startResponse, '')

def createStageCmd(startResponse, jsonDict):

  try:
    requestID = int(jsonDict['request_id'])
  except:
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'Request ID must be given')
  try:
    stageID = int(jsonDict['stage_id'])
  except:
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'Stage ID must be given')

  try:
    processors = int(jsonDict['processors'])
  except:
    processors = 1

  try:
    wallSeconds = int(jsonDict['wall_seconds'])
  except:
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'Wall seconds must be given')

  try:
    rssBytes = int(jsonDict['rss_mb']) * 1024 * 1024
  except:
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'RSS MB must be given')

  if 'max_distance' in jsonDict and jsonDict['max_distance']:
    try:
      maxDistance = float(jsonDict['max_distance'])
    except:
      return httpError(startResponse, 
                       '400 Bad Request', 
                       '--max-distance option requires a numeric distance')
  else:
    maxDistance = 0.0

  if 'file' in jsonDict and jsonDict['file']:
    bootstrap = jsonDict['file']
  else:
    return httpError(startResponse,
                     '400 Bad Request',
                     'Upload file is required')

  try:
    wfs.db.insertUpdate("INSERT INTO stages SET "
                        "request_id=%d,"
                        "stage_id=%d,"
                        "processors=%d,"
                        "wall_seconds=%d,"
                        "rss_bytes=%d,"
                        "max_distance=%f" % 
                        (requestID, stageID, processors,
                         wallSeconds, rssBytes, maxDistance))
          
    wfs.db.insertUpdate('INSERT INTO bootstraps SET '
                        'request_id=%d,'
                        'stage_id=%d,'
                        'bootstrap="%s"' % 
                        (requestID, stageID, 
                         bootstrap.replace('\\','\\\\').replace('"','\\"')))

  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error updating workflow database ' + str(e))

  try:
    lifetimeDays = int(jsonDict['lifetime_days'])
  except:
    lifetimeDays = 1

  if jsonDict['output_pattern']:
    for i in jsonDict['output_pattern']:
    
      splitList = i.split(':')
       
      if len(splitList) < 3:
        continue
    
      scope       = splitList[0]
      datasetName = splitList[1]
      pattern     = ':'.join(splitList[2:])
        
      try:
        wfs.db.insertUpdate('INSERT INTO stages_outputs SET '
              'request_id=%d,'
              'stage_id=%d,'
              'dataset="%s:%s",'
              'file_scope="%s",'
              'file_pattern="%s",'
              'lifetime_seconds=%d,'
              'for_next_stage=FALSE' % 
              (requestID, stageID,
               scope.replace('\\','\\\\').replace('"','\\"'),
               datasetName.replace('\\','\\\\').replace('"','\\"'),
               scope.replace('\\','\\\\').replace('"','\\"'),
               pattern.replace('\\','\\\\').replace('"','\\"'),
               lifetimeDays * 86400
              )
             )

      except Exception as e:
        return httpError(startResponse, 
                         '500 Internal Server Error', 
                         'Error updating workflow database ' + str(e))

  if jsonDict['output_pattern_next_stage']:
    for i in jsonDict['output_pattern_next_stage']:
    
      splitList = i.split(':')
       
      if len(splitList) < 3:
        continue
    
      scope        = splitList[0]
      datasetName  = splitList[1]
      pattern      = ':'.join(splitList[2:])

      try:        
        wfs.db.insertUpdate('INSERT INTO stages_outputs SET '
              'request_id=%d,'
              'stage_id=%d,'
              'dataset="%s:%s",'
              'file_scope="%s",'
              'file_pattern="%s',
              'lifetime_seconds=%d,'
              'for_next_stage=TRUE' % 
              (requestID, stageID,
               scope.replace('\\','\\\\').replace('"','\\"'),
               datasetName.replace('\\','\\\\').replace('"','\\"'),
               scope.replace('\\','\\\\').replace('"','\\"'),
               pattern.replace('\\','\\\\').replace('"','\\"'),
               lifetimeDays * 86400
              )
             )

      except Exception as e:
        return httpError(startResponse, 
                         '500 Internal Server Error', 
                         'Error updating workflow database ' + str(e))
          
  if jsonDict['output_rse']:
    for rseName in jsonDict['output_rse']:
    
      if not wfs.db.stringIsSite(rseName):
        return httpError(startResponse, 
                         '400 Bad Request', 
                         'Invalid RSE name')

      try:        
        wfs.db.insertUpdate('INSERT INTO stages_output_storages SET '
              'request_id=%d,'
              'stage_id=%d,'
              'rse_id=(SELECT rse_id FROM storages WHERE rse_name="%s")' % 
              (requestID, stageID, rseName))

      except Exception as e:
        return httpError(startResponse, 
                         '500 Internal Server Error', 
                         'Error updating workflow database ' + str(e))

  return httpOK(startResponse, '')

def createBootstrapCmd(startResponse, jsonDict):

  try:
    requestID = int(jsonDict['request_id'])
  except:
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'Request ID must be given')

  try:
    stageID = int(jsonDict['stage_id'])
  except:
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'Stage ID must be given')

  if 'file' in jsonDict and jsonDict['file']:
    bootstrap = jsonDict['file']
  else:
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'Upload file is required')

  try:
    wfs.db.insertUpdate('UPDATE bootstraps SET bootstrap="%s" '
                        'WHERE request_id=%d AND stage_id=%d'
                        % (bootstrap.replace('\\','\\\\').replace('"','\\"'),
                           requestID, stageID))

  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error updating workflow database ' + str(e))

  return httpOK(startResponse, '')

def addFileCmd(startResponse, jsonDict):

  try:
    requestID = int(jsonDict['request_id'])
  except:
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'Request ID must be given')

  try:
    stageID = int(jsonDict['stage_id'])
  except:
    stageID = 1

  try:
    fileDID = str(jsonDict['file_did'])
  except:
    fileDID = None

  if fileDID is None:
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'File DID must be given')

  rseList = []

  try:
    for rseName in jsonDict['rse_name']:
      rseList.append(re.sub('[^A-Za-z0-9._-]+', '', str(rseName)))
  except:
    rseList = []
    
  if len(rseList) == 0:
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'At least one RSE name must be given')

  try:
    wfs.db.insertUpdate("INSERT INTO files SET "
          "request_id=%d,"
          "stage_id=%d,"
          "file_did='%s',"
          "state='unallocated'" % 
          (requestID, stageID, fileDID))

  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error updating workflow database ' + str(e))

  fileID = wfs.db.cur.lastrowid

  for rseName in rseList:
    try:
      wfs.db.insertUpdate("INSERT INTO replicas SET "
            "rse_id=(SELECT rse_id FROM storages WHERE rse_name='%s'),"
            "file_id=%d,request_id=%d,stage_id=%d" % 
            (rseName, fileID, requestID, stageID))

    except Exception as e:
      return httpError(startResponse, 
                       '500 Internal Server Error', 
                       'Error updating workflow database ' + str(e))
      
  return httpOK(startResponse, '')

def showJobsCmd(startResponse, jsonDict):

  try:
    jobsubID = jsonDict['jobsub_id']
  except:
    jobsubID = None
  
  try:
    requestID = int(jsonDict['request_id'])
  except:
    requestID = None
  
  try:
    stageID = int(jsonDict['stage_id'])
  except:
    stageID = 1
  
  if jobsubID:
    filter = "WHERE jobsub_id='%s'" % jobsubID 
  elif requestID:
    filter = "WHERE request_id=%d AND stage_id=%d" % (requestID, stageID)
  else:
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'Either Jobsub ID or Request ID must be given')

  if jsonDict['state']:
    try:  
      filter += (' AND allocation_state="' +
                 re.sub('[^a-z]+', '', str(jsonDict['state'])) +
                 '"'
                )
    except:
      pass

  try:
    rows = wfs.db.select("SELECT jobsub_id,request_id,stage_id,"
                         "allocation_state,allocation_time "
                         "FROM jobs "
                         + filter +
                         " ORDER BY wfs_job_id")
  except Exception as e:
    return httpError(startResponse, 
                     '500 Internal Server Error', 
                     'Error reading workflow database ' + str(e))

  outputString = ''
  for row in rows:
    outputString += ("%30s %5s %2s %10s  %s\n" % 
                     (row['jobsub_id'], row['request_id'], row['stage_id'], 
                      row['allocation_state'], row['allocation_time']))
   
  return httpOK(startResponse, outputString)

def getUserID(environ, startResponse):

  # Use certificates and proxies for now; will transition to tokens in future
  if 'SSL_CLIENT_S_DN' not in environ or not environ['SSL_CLIENT_S_DN']:
    return httpError(startResponse, 
                     '403 Forbidden', 
                     'Forbidden - identity not provided')

  # Convert to the older format with slashes 
  clientDN='/'+'/'.join(environ['SSL_CLIENT_S_DN'].split(',')[::-1])

  try:
    rows = wfs.db.select('SELECT user_id FROM x509 '
                         'WHERE x509dn=LEFT("%s",LENGTH(x509dn))' % 
                         clientDN.replace('\\','\\\\').replace('"','\\"'))
  
    userID = int(rows[0]['user_id'])
  except:
    return httpError(startResponse, 
                     '403 Forbidden', 
                     'Forbidden - acceptable identity not provided')

  return userID

#
# Entry point from mod_wsgi
#
def application(environ, startResponse):

  # Avoid leftovers from partial, failed transactions in this instance
  wfs.db.conn.rollback()

  # Quickly reject random GETs etc (if not hanlded by Apache already)
  if environ['REQUEST_METHOD'] != 'POST':
    return httpError(startResponse, 
                     '405 Method not allowed', 
                     'We only support POST')

  try:
    # True should provoke a reconnection attempt.
    # See https://github.com/farcepest/MySQLdb1/blob/master/_mysql.c#L1978
    # (Not sure if there is a more authoritative source for this API.)
    wfs.db.conn.ping(True)
  except Exception as e:
    return httpError(startResponse,
                     '500 Internal Server Error',
                     'DB connection lost and cannot reconnect: ' + str(e))

  # This returns an error if an authorized DN is not found
  response = getUserID(environ, startResponse)
  if isinstance(response, int):
    userID = response
  else:
    return response   

  try:
    inputLength = int(environ.get('CONTENT_LENGTH', '0'))
    inputString = environ['wsgi.input'].read(inputLength)
    jsonDict = json.loads(inputString)
  except Exception as e:
    return httpError(startResponse, 
                     '400 Bad Request', 
                     'Failed to read and parse JSON')

  # Check jsonDict specifies a method
  if 'command' not in jsonDict:
    return httpError(startResponse,
                     '400 Bad Request', 
                     'Missing command in JSON')

  if jsonDict['command'] == 'show-requests':
    return showRequestsCmd(startResponse, jsonDict)

  if jsonDict['command'] == 'show-stages':
    return showStagesCmd(startResponse, jsonDict)

  if jsonDict['command'] == 'show-bootstrap':
    return showBootstrapCmd(startResponse, jsonDict)

  if jsonDict['command'] == 'show-stage-outputs':
    return showStageOutputsCmd(startResponse, jsonDict)

  if jsonDict['command'] == 'show-files':
    return showFilesCmd(startResponse, jsonDict)

  if jsonDict['command'] == 'show-replicas':
    return showReplicasCmd(startResponse, jsonDict)

  if jsonDict['command'] == 'show-storages':
    return showStoragesCmd(startResponse, jsonDict)

  if jsonDict['command'] == 'show-sites-storages':
    return showSitesStoragesCmd(startResponse, jsonDict)

  if jsonDict['command'] == 'create-request':
    return createRequestCmd(startResponse, jsonDict, userID)

  if jsonDict['command'] == 'quick-request':
    return quickRequestCmd(startResponse, jsonDict, userID)

  if jsonDict['command'] == 'submit-request':
    return submitRequestCmd(startResponse, jsonDict)

  if jsonDict['command'] == 'start-request':
    return startRequestCmd(startResponse, jsonDict)

  if jsonDict['command'] == 'pause-request':
    return pauseRequestCmd(startResponse, jsonDict)

  if jsonDict['command'] == 'finish-request':
    return finishRequestCmd(startResponse, jsonDict)

  if jsonDict['command'] == 'create-stage':
    return createStageCmd(startResponse, jsonDict)

  if jsonDict['command'] == 'create-bootstrap':
    return createBootstrapCmd(startResponse, jsonDict)

  if jsonDict['command'] == 'add-file':
    return addFileCmd(startResponse, jsonDict)

  if jsonDict['command'] == 'show-jobs':
    return showJobsCmd(startResponse, jsonDict)

  return httpError(startResponse,
                   '400 Bad Request', 
                   'command in JSON not recognised')
